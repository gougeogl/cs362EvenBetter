        -:    0:Source:bug7unittest.c
        -:    0:Graph:bug7unittest.gcno
        -:    0:Data:bug7unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*************************************************
        -:    2:* FileName: bug7unittest.c
        -:    3:* Author:	Glen Gougeon
        -:    4:* Class:	CS362 Software Engineering II
        -:    5:* Created:	11-30-2019
        -:    6:* Last Mod:	12-1-2019
        -:    7:*
        -:    8:* Assignement: Final Project Part B/
        -:    9:*
        -:   10:* Description:	Unit Test for Bug 7:
        -:   11:*				TributeRevealedCards Buffer-OverRun
        -:   12:*
        -:   13:**************************************************/
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "interface.h"
        -:   22:#include "rngs.h"
        -:   23:
        -:   24:// TEST PROTO-TYPES
        -:   25:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game);
        -:   26:
        -:   27:// sets variable states and calls 'cardEffect' w/ 'tribute' as card
        -:   28:void subTestTribute(
        -:   29:	int testNo,
        -:   30:	char* message,
        -:   31:	struct gameState* oldState,
        -:   32:	struct gameState* newState,
        -:   33:	int newHandSize,
        -:   34:	int tribute_index,
        -:   35:	int cardInDeck
        -:   36:);
        -:   37:
        -:   38:// must be called after subTestTribute
        -:   39:void runAsserts(
        -:   40:	struct gameState* before, 
        -:   41:	struct gameState* after 
        -:   42:);
        -:   43:
        -:   44:// HELPER PROTOS-TYPES
        -:   45:void emptyDeck(int player, struct gameState* state);
        -:   46:void emptyPlayedCards(struct gameState* state);
        -:   47:void emptyDiscard(int player, struct gameState* state);
        -:   48:
        -:   49:// HAND RELATED PROTO-TYPES
        -:   50:void emptyHand(int player, struct gameState* dState);
        -:   51:void setNewHandCount(int player, struct gameState* state, int newHandSize);
        -:   52:void setAtHandPos(int player, struct gameState* state, int card, int handPos);
        -:   53:
function main called 1 returned 100% blocks executed 100%
        -:   54:int main()
        -:   55:{
        1:   56:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        1:   57:	printf("*** START Bug7 Unit Test: TributeRevealedCards Buffer-OverRun ***\n");
        1:   58:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        -:   59:
        1:   60:	int kingdomCards[10] = { adventurer, ambassador, baron, curse, estate, tribute, minion, mine, gardens, remodel };
        -:   61:
        -:   62:	struct gameState G;
        -:   63:	struct gameState backup;
        -:   64:
        1:   65:	int seed = 1;
        1:   66:	int numPlayers = 2;
        -:   67:	//int currentPlayer = 0;
        1:   68:	int newHandSize = 1;
        1:   69:	int tribute_index = 0; // handPos tribute .. not really used
        1:   70:	int cardInDeck = -1;
        1:   71:	char* test_1_message = "Place 2 treasures at top of next player's deck, then call tribute.";
        1:   72:	char* test_2_message = "Place 2 Victory cards at top of next player's deck, then call tribute.";
        1:   73:	char* test_3_message = "Place 2 Action cards at top of next player's deck, then call tribute.";
        1:   74:	char* test_4_message = "Place 2 Curses at top of next player's deck, then call tribute.";
        -:   75:
        -:   76:	// SUBTEST 1 -- 2 treasure cards
        1:   77:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   78:	cardInDeck = gold;
        1:   79:	subTestTribute(1, test_1_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:   80:	runAsserts(&backup,&G);
        1:   81:	printf("------------------------------------------------------------------------------------\n");
        -:   82:
        -:   83:	// SUBTEST 2 -- 2 victory cards
        1:   84:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   85:	cardInDeck = estate;
        1:   86:	subTestTribute(2, test_2_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:   87:	runAsserts(&backup, &G);
        1:   88:	printf("------------------------------------------------------------------------------------\n");
        -:   89:
        -:   90:	// SUBTEST 3 -- 2 action cards
        1:   91:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   92:	cardInDeck = estate;
        1:   93:	subTestTribute(3, test_3_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:   94:	runAsserts(&backup, &G);
        1:   95:	printf("------------------------------------------------------------------------------------\n");
        -:   96:
        -:   97:	// SUBTEST 4 -- 2 curse cards
        1:   98:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   99:	cardInDeck = curse;
        1:  100:	subTestTribute(4, test_4_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:  101:	runAsserts(&backup, &G);
        -:  102:
        1:  103:	return 0;
        -:  104:}
        -:  105:
        -:  106:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  107:/* *** FUNCTION SPECIFICATIONS ***																	*/
        -:  108:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  109:
        -:  110:/* This function adds memset initialization, and prints error if fail  */
function initTestGame called 4 returned 100% blocks executed 75%
        -:  111:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game)
        -:  112:{
        4:  113:	memset(game, '\0', sizeof(struct gameState));   // clear mem of 
        -:  114:
        4:  115:	int checkInit = initializeGame(numPlayers, kDeck, mySeed, game); // initialize 2 player game 
        -:  116:
        4:  117:	if (checkInit == -1)
branch  0 taken 0%
branch  1 taken 100%
        -:  118:	{
    #####:  119:		printf("Bad game initialization.\n");
    #####:  120:	}
        -:  121:
        4:  122:}
        -:  123:
        -:  124:// set player to remove all cards from current player's deck  
function emptyDeck called 8 returned 100% blocks executed 100%
        -:  125:void emptyDeck(int player, struct gameState* state)
        -:  126:{
        8:  127:	int i = 0;
      136:  128:	while (i < state->deckCount[player])
branch  0 taken 88%
branch  1 taken 12%
        -:  129:	{
       60:  130:		state->deck[player][i] = -1;
       60:  131:		i++;
        -:  132:	}
        8:  133:	state->deckCount[player] = 0;
        8:  134:}
        -:  135:
        -:  136:// set player to remove all cards from current player's deck   
function emptyPlayedCards called 8 returned 100% blocks executed 80%
        -:  137:void emptyPlayedCards(struct gameState* state)
        -:  138:{
        8:  139:	int i = 0;
       16:  140:	while (i < state->playedCardCount)
branch  0 taken 0%
branch  1 taken 100%
        -:  141:	{
    #####:  142:		state->playedCards[i] = -1;
    #####:  143:		i++;
        -:  144:	}
        8:  145:	state->playedCardCount = 0;
        8:  146:}
        -:  147:
        -:  148:// eliminate all cards from discard.   
function emptyDiscard called 8 returned 100% blocks executed 80%
        -:  149:void emptyDiscard(int player, struct gameState* state)
        -:  150:{
        8:  151:	int i = 0;
       16:  152:	while (i < state->discardCount[player])
branch  0 taken 0%
branch  1 taken 100%
        -:  153:	{
    #####:  154:		state->discard[player][i] = -1;
    #####:  155:		i++;
        -:  156:	}
        8:  157:	state->discardCount[player] = 0;
        8:  158:}
        -:  159:
        -:  160:/* Sets current player's handCount to newHandSize, then
        -:  161:	overwrites everything in hand with -1 */
function emptyHand called 8 returned 100% blocks executed 100%
        -:  162:void emptyHand(int player, struct gameState* state)
        -:  163:{
        -:  164:	int i;
       56:  165:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 71%
branch  1 taken 29%
        -:  166:	{
       20:  167:		state->hand[player][i] = -1;
       20:  168:	}
        8:  169:	state->handCount[player] = 0;
        8:  170:}
        -:  171:
        -:  172:// sets handCount of player to newHandSize
function setNewHandCount called 4 returned 100% blocks executed 100%
        -:  173:void setNewHandCount(int player, struct gameState* state, int newHandSize)
        -:  174:{
        4:  175:	state->handCount[player] = newHandSize;
        4:  176:}
        -:  177:
        -:  178:// adds indicated card in current player's hand at handPos 
function setAtHandPos called 4 returned 100% blocks executed 100%
        -:  179:void setAtHandPos(int player, struct gameState* state, int card, int handPos)
        -:  180:{
        4:  181:	state->hand[player][handPos] = card;
        4:  182:}
        -:  183:
        -:  184:// Use for running subtest on 'tribute' case of 'cardEffect' function
function subTestTribute called 4 returned 100% blocks executed 100%
        -:  185:void subTestTribute(
        -:  186:	// parameters
        -:  187:	int testNo,
        -:  188:	char* message,
        -:  189:	struct gameState* oldState, 
        -:  190:	struct gameState* newState, 
        -:  191:	int newHandSize, 
        -:  192:	int tribute_index, 
        -:  193:	int cardInDeck)
        -:  194:	// end paramaters
        -:  195:{
        4:  196:	printf(" SUB-TEST %d: %s\n\n", testNo, message);
        -:  197:
        -:  198:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  199:	/* ** SETUP TEST SECTION ** */
        -:  200:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  201:
        4:  202:	int idxOfChoice1 = 0; // choice1 tribute
        4:  203:	int blank = -1;
        4:  204:	int coinBonus = 0;
        4:  205:	int currentPlayer = newState->whoseTurn;
        4:  206:	int nextPlayer = currentPlayer + 1;
        -:  207:
        -:  208:	/* MMMMMMMMM SET UP CURRENT PLAYER *** MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
        -:  209:
        -:  210:	// empty every deck currentPlayer has
        4:  211:	emptyDeck(currentPlayer, newState);
        4:  212:	emptyPlayedCards(newState); // req'd. b/c 'discardCard' is broken !!
        4:  213:	emptyDiscard(currentPlayer, newState);
        4:  214:	emptyHand(currentPlayer, newState);
        -:  215:
        -:  216:	// set up new hand size after empty
        4:  217:	setNewHandCount(currentPlayer, newState, newHandSize);
        -:  218:
        -:  219:	// place tribute card in hand
        4:  220:	setAtHandPos(currentPlayer, newState, tribute, tribute_index);
        -:  221:
        -:  222:	// set coins appropriately
        4:  223:	updateCoins(currentPlayer, newState, coinBonus);
        -:  224:
        -:  225:	/* MMMMMMMMM SET UP NEXT PLAYER *** MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
        -:  226:
        -:  227:	// empty every deck currentPlayer has
        4:  228:	emptyDeck(nextPlayer, newState);
        4:  229:	emptyPlayedCards(newState); // req'd. b/c 'discardCard' is broken !!
        4:  230:	emptyDiscard(nextPlayer, newState);
        4:  231:	emptyHand(nextPlayer, newState);
        -:  232:
        -:  233:	// subtest 1 = ensure only 2 golds are in next player's hand
        -:  234:	// subtest 2 = ensure only 2 victory cards are in next player's hand
        -:  235:	// subtest 3 = ensure only 2 action cards are in next player's hand
        -:  236:	// subtest 4 = ensure only 2..
        -:  237:	//			   non-treasure, non-victory, non-action cards are in next player's hand
        -:  238:
        -:  239:	// empty supply of cardInDeck to ensure the ones 
        -:  240:	// going into deck are the only ones possible
        4:  241:	newState->supplyCount[cardInDeck] = 0;
        -:  242:
        -:  243:	// place 2 cards in nextPlayer's deck then increment
        4:  244:	newState->deck[nextPlayer][newState->deckCount[nextPlayer]] = cardInDeck;
        4:  245:	newState->deckCount[nextPlayer]++;
        4:  246:	newState->deck[nextPlayer][newState->deckCount[nextPlayer]] = cardInDeck;
        4:  247:	newState->deckCount[nextPlayer]++;
        -:  248:
        -:  249:	/* BACK UP STATE BEFORE CALL */
        4:  250:	memset(oldState, '\0', sizeof(*oldState));
        4:  251:	oldState = newState;
        -:  252:
        -:  253:	/* CALL TO TRIBUTE <-----------------------------------------------------*/
        4:  254:	cardEffect(tribute, idxOfChoice1, blank, blank, newState, tribute_index, &coinBonus);
        -:  255:
        4:  256:}
        -:  257:
        -:  258:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  259:/* ** ASSERTS SECTION ** */
        -:  260:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
function runAsserts called 4 returned 100% blocks executed 47%
        -:  261:void runAsserts(struct gameState* before, struct gameState* after)
        -:  262:{
        4:  263:	int currentPlayer = after->whoseTurn;
        4:  264:	int nextPlayer = currentPlayer +1;
        -:  265:
        -:  266:	char name[MAX_STRING_LENGTH];
        -:  267:	char nombre[MAX_STRING_LENGTH];
        -:  268:
        -:  269:	/*Assert that the top 2 cards from the next player's previous deck
        -:  270:	are exactly the ones found in their discard (playedCards) after the use of tribute.*/
        4:  271:	if (before->deck[nextPlayer][before->deckCount[nextPlayer] - 1] != after->discard[nextPlayer][after->discardCount[nextPlayer] - 1])
branch  0 taken 0%
branch  1 taken 100%
        -:  272:	{
    #####:  273:		if (before->deck[nextPlayer][before->deckCount[nextPlayer] - 2] != after->discard[nextPlayer][after->discardCount[nextPlayer] - 2])
branch  0 never executed
branch  1 never executed
        -:  274:		{
    #####:  275:			memset(name, '\0', sizeof name);
    #####:  276:			cardNumToName(after->discard[nextPlayer][after->discardCount[nextPlayer] - 1], name);
        -:  277:
    #####:  278:			memset(nombre, '\0', sizeof nombre);
    #####:  279:			cardNumToName(after->discard[nextPlayer][after->discardCount[nextPlayer] - 1], nombre);
        -:  280:
    #####:  281:			printf("Tribute Error: previous top 2 deck cards next player..\n");
    #####:  282:			printf("               not found in next player's discard.\n\n");
    #####:  283:			printf("               Discard top 2:\n");
    #####:  284:			printf("               G.discard[%d]: %s\n", after->discardCount[nextPlayer] - 1, name);
    #####:  285:			printf("               G.discard[%d]: %s\n\n", after->discardCount[nextPlayer] - 2, nombre);
    #####:  286:		}
    #####:  287:	}
        -:  288:
        -:  289:	/*Assert that the counts of the next player's discard and deck counts
        -:  290:	are correct, such that their deckCount is 2 less than previously, and
        -:  291:	their discardCount is 2 greater than previously.*/
        4:  292:	if (before->deckCount[nextPlayer] - 2 != after->deckCount[nextPlayer])
branch  0 taken 0%
branch  1 taken 100%
        -:  293:	{
    #####:  294:		if (before->discardCount[nextPlayer] + 2 != after->discardCount[nextPlayer])
branch  0 never executed
branch  1 never executed
        -:  295:		{
    #####:  296:			printf("Tribute Error: next player's deckCount not -2 previous.\n");
    #####:  297:			printf("             : next player's discardCount not +2 previous.\n\n");
        -:  298:
    #####:  299:		}
    #####:  300:	}
        -:  301:
        -:  302:	/*Assert if one of the top 2 cards in the next player's discard
        -:  303:	are a coin, that the current player's coin is exactly 2 greater than previously.
        -:  304:	for each treasure in discard*/
        4:  305:	int totalCoin = 0;
        8:  306:	if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == copper ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        4:  307:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == silver ||
branch  0 taken 100%
branch  1 taken 0%
        4:  308:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == gold) {
        -:  309:
        -:  310:		// 1 treasure found
    #####:  311:		totalCoin += 2;
        -:  312:
    #####:  313:		if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == copper ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  314:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == silver ||
branch  0 never executed
branch  1 never executed
    #####:  315:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == gold) {
        -:  316:
        -:  317:			// 2nd treasure found
    #####:  318:			totalCoin += 2;
    #####:  319:		}
    #####:  320:	}
        -:  321:
        4:  322:	if (totalCoin == 2)
branch  0 taken 0%
branch  1 taken 100%
        -:  323:	{
    #####:  324:		if (before->coins + 2 != after->coins)
branch  0 never executed
branch  1 never executed
        -:  325:		{
    #####:  326:			printf("Tribute Error: You had 1 treasure in discard, but didn't gain 2 coin.\n\n");
    #####:  327:		}
    #####:  328:	}
        4:  329:	else if (totalCoin == 4)
branch  0 taken 0%
branch  1 taken 100%
        -:  330:	{
    #####:  331:		if (before->coins + 4 != after->coins)
branch  0 never executed
branch  1 never executed
        -:  332:		{
    #####:  333:			printf("Tribute Error: You had 2 treasures in discard, but didn't gain 4 coin.\n\n");
    #####:  334:		}
    #####:  335:	}
        -:  336:	/*Assert that if the current player's coin went up by 2 from previous, that
        -:  337:	the next player's top 2 discarded cards are a coin, otherwise print a message*/
        8:  338:	else if (totalCoin == 0 && (before->coins != after->coins))
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 25%
branch  3 taken 75%
        -:  339:	{
        1:  340:		printf("Tribute Error: You gained coin, but didn't find a treasure in discard.\n\n");
        1:  341:	}
        -:  342:
        -:  343:	/*Assert if one of the top 2 cards in the next player's discard
        -:  344:	are a victory card, that the current player's handCount is 2 greater than previously.*/
        4:  345:	int totalVictory = 0;
        8:  346:	if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == estate ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        4:  347:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == gardens) {
        -:  348:
        -:  349:		// 1 treasure found
    #####:  350:		totalVictory += 2;
        -:  351:
    #####:  352:		if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == estate ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  353:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == gardens) {
        -:  354:
        -:  355:			// 2nd treasure found
    #####:  356:			totalVictory += 2;
    #####:  357:		}
    #####:  358:	}
        -:  359:
        4:  360:	if (totalVictory == 2)
branch  0 taken 0%
branch  1 taken 100%
        -:  361:	{
    #####:  362:		if (before->handCount[nextPlayer] + 2 != after->handCount[nextPlayer])
branch  0 never executed
branch  1 never executed
        -:  363:		{
    #####:  364:			printf("Tribute Error: You had 1 Victory card in discard, but didn't gain 2 card.\n\n");
    #####:  365:		}
    #####:  366:	}
        4:  367:	else if (totalVictory == 4)
branch  0 taken 0%
branch  1 taken 100%
        -:  368:	{
    #####:  369:		if (before->handCount[nextPlayer] + 4 != after->handCount[nextPlayer])
branch  0 never executed
branch  1 never executed
        -:  370:		{
    #####:  371:			printf("Tribute Error: You had 2 Victory card in discard, but didn't gain 4 cards.\n\n");
    #####:  372:		}
    #####:  373:	}
        -:  374:	/*Assert that if the current player's hand count went up by 2 from previous, that
        -:  375:	the next player's top 2 discarded cards are a victory card.*/
        8:  376:	else if (totalVictory == 0 && (before->handCount[nextPlayer] != after->handCount[nextPlayer]))
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:  377:	{
    #####:  378:		printf("Tribute Error: You gained cards in hand, but didn't find a Victory card in discard.\n\n");
    #####:  379:	}
        -:  380:
        -:  381:	// This will catch the error.
        -:  382:	/*Assert that if the current player's numActions went up by 2 from previous, that
        -:  383:	the next player's top 2 discarded cards are an action card, otherwise print a message*/
        -:  384:
        4:  385:	int totalActions = 0;
        8:  386:	if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == adventurer ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        4:  387:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == baron ||
branch  0 taken 100%
branch  1 taken 0%
        4:  388:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == tribute ||
branch  0 taken 100%
branch  1 taken 0%
        4:  389:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == minion ||
branch  0 taken 100%
branch  1 taken 0%
        4:  390:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == mine ||
branch  0 taken 100%
branch  1 taken 0%
        4:  391:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == remodel) {
        -:  392:
        -:  393:		// 1 action found
    #####:  394:		totalActions += 2;
        -:  395:
    #####:  396:		if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == adventurer ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  397:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == baron ||
branch  0 never executed
branch  1 never executed
    #####:  398:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == tribute ||
branch  0 never executed
branch  1 never executed
    #####:  399:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == minion ||
branch  0 never executed
branch  1 never executed
    #####:  400:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == mine ||
branch  0 never executed
branch  1 never executed
    #####:  401:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == remodel) {
        -:  402:
        -:  403:			// 2nd actions found
    #####:  404:			totalActions += 4;
    #####:  405:		}
    #####:  406:	}
        -:  407:
        4:  408:	if (totalActions == 2)
branch  0 taken 0%
branch  1 taken 100%
        -:  409:	{
    #####:  410:		if (before->numActions + 2 != after->numActions)
branch  0 never executed
branch  1 never executed
        -:  411:		{
    #####:  412:			printf("Tribute Error: You had 1 action card in discard, but didn't gain 2 actions.\n\n");
    #####:  413:		}
    #####:  414:	}
        4:  415:	else if (totalActions == 4)
branch  0 taken 0%
branch  1 taken 100%
        -:  416:	{
    #####:  417:		if (before->numActions + 4 != after->numActions)
branch  0 never executed
branch  1 never executed
        -:  418:		{
    #####:  419:			printf("Tribute Error: You had 2 action cards in discard, but didn't gain 4 actions.\n\n");
    #####:  420:		}
    #####:  421:	}
        8:  422:	else if (totalActions == 0 && (before->numActions != after->numActions))
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  423:	{
        4:  424:		printf("Tribute Error: You gained actions, but didn't find any action cards in discard.\n\n");
        4:  425:	}
        -:  426:
        -:  427:	/*Assert that if the current player's hand count went up 2 from previous, that
        -:  428:	the next player's top 2 discarded cards are a victory card.
        -:  429:		If so compare the hands to see that the contents of the current player's hand
        -:  430:		is no the same as before.Use a for loop for i in G.handCount[currentPlayer],
        -:  431:		and compare contents.Any difference should break out of loop, set a print flag,
        -:  432:		and print the error.*/
        4:  433:	if (after->handCount[currentPlayer] > before->handCount[currentPlayer])
branch  0 taken 100%
branch  1 taken 0%
        -:  434:	{
        4:  435:		if ((after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] != estate ||
branch  0 taken 0%
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  436:		     after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] != estate) &&
branch  0 never executed
branch  1 never executed
        4:  437:		    (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] != gardens ||
branch  0 taken 0%
branch  1 taken 100%
    #####:  438:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] != gardens) ){
        -:  439:
        -:  440:				// Then your handCount increased withou having a Victory card
        4:  441:				printf("Tribute Error: Your hand increased but..\n");
        4:  442:				printf("             : top 2 cards in next player's discard weren't Victory cards.\n\n");
        4:  443:			}
        4:  444:	}
        4:  445:}
