MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*** START Bug1 Unit Test: Mine Money to Trash Only Discards ***
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Note* discardCard() broken. Where would test contents of discard..
      I am testing against contents of playedCards instead.

Error Mine: choice1 found in playedCards, but should be at top of trashPile.

Error Mine: playedCardCount changed.

Error Mine: choice2 not found in hand after the call.

*** END Bug1 Unit Test ***

MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*** START Bug1-B Unit Test: Remodel Trash Failure ***
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Note* discardCard() broken. Where would test contents of discard..
      I am testing against contents of playedCards instead.

Error Remodel: choice1 is still the same but shouldn't be.

Error Remodel: choice1 found in playedCards, but should be at top of trashPile.

Error Remodel. choice2 card to gain not found in top of discard after remodel.
               *actually not in playedCards .. b/c that is where 'discardCard' places cards.

*** END Bug1-B Unit Test ***



Begin Testing Mine cardEffect:
Choice of card to gain determined as invalid. Error encountered.



Begin Testing Remodel cardEffect:
Choice of card to gain determined as invalid. Error encountered.



Begin Testing isGameOver():
Game over status is incorrectly detected for 3 empty piles. Error detected.

/****************************************
/***********   BUG 5 TEST   *************
/****************************************
Score is correctly calculated for current player. No errors.




/****************************************
/***********   BUG 6 TEST   *************
/****************************************

I actually spent a lot of time debugging this section before concluding that there is, in fact, no bug.
The full write-up can be found in Part A, but a synopsis is below:

The bug thread states that the updateCoins function is causing a bug by simply giving the player 5 coins.
The argument is that this allows the player to spend more than 5 coins or keep the extras that are unspent.
However, this is based on a misunderstanding of updateCoins(). This function doesn't simply give coins.
Rather, it resets the coin count, and then gives fresh coins according to the player's hand and any passed-in bonus.
In Feast, the hand is set to -1, and then 5 is passed into the updateCoins as a bonus, effectively resetting the coin count to 5, regardless of a player's treasure cards or existing coins.
Then, the hand is restored, and updateCoins is called again with a bonus of 0, clearing any leftover coins from Feast.
Together, these negate both of the bugs listed in the bug thread. There is no bug with updateCoins in Feast.



MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*** START Bug7 Unit Test: TributeRevealedCards Buffer-OverRun ***
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
 SUB-TEST 1: Place 2 treasures at top of next player's deck, then call tribute.

Tribute Error: You gained coin, but didn't find a treasure in discard.

Tribute Error: You gained actions, but didn't find any action cards in discard.

Tribute Error: Your hand increased but..
             : top 2 cards in next player's discard weren't Victory cards.

------------------------------------------------------------------------------------
 SUB-TEST 2: Place 2 Victory cards at top of next player's deck, then call tribute.

Tribute Error: You gained actions, but didn't find any action cards in discard.

Tribute Error: Your hand increased but..
             : top 2 cards in next player's discard weren't Victory cards.

------------------------------------------------------------------------------------
 SUB-TEST 3: Place 2 Action cards at top of next player's deck, then call tribute.

Tribute Error: You gained actions, but didn't find any action cards in discard.

Tribute Error: Your hand increased but..
             : top 2 cards in next player's discard weren't Victory cards.

------------------------------------------------------------------------------------
 SUB-TEST 4: Place 2 Curses at top of next player's deck, then call tribute.

Tribute Error: You gained actions, but didn't find any action cards in discard.

Tribute Error: Your hand increased but..
             : top 2 cards in next player's discard weren't Victory cards.

/****************************************
/***********   BUG 8 TEST   *************
/****************************************

Testing gaining bonus coins....
Coins are correctly calculated for current player! No errors.




MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*** START Bug9 Unit Test: TributeRevealedCards Illegal Action Gain ***
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

 SUB-TEST 1: Place 2 treasures at top of next player's deck, then call tribute.

Tribute Error: You gained coin, but didn't find a treasure in discard.

Tribute Error: You gained actions, but didn't find any action cards in discard.

Tribute Error: Your hand increased but..
             : top 2 cards in next player's discard weren't Victory cards.

------------------------------------------------------------------------------------
 SUB-TEST 2: Place 2 Victory cards at top of next player's deck, then call tribute.

Tribute Error: You gained actions, but didn't find any action cards in discard.

Tribute Error: Your hand increased but..
             : top 2 cards in next player's discard weren't Victory cards.

------------------------------------------------------------------------------------
 SUB-TEST 3: Place 2 non-coin & non-victory (curses) at top of next player's deck, then call tribute.

Tribute Error: You gained actions, but didn't find any action cards in discard.

Tribute Error: Your hand increased but..
             : top 2 cards in next player's discard weren't Victory cards.

------------------------------------------------------------------------------------
Function 'compare'
Lines executed:83.33% of 6
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

Function 'newGame'
Lines executed:0.00% of 2
No branches
No calls

Function 'kingdomCards'
Lines executed:100.00% of 12
No branches
No calls

Function 'initializeGame'
Lines executed:85.90% of 78
Branches executed:95.65% of 46
Taken at least once:80.43% of 46
No calls

Function 'shuffle'
Lines executed:100.00% of 18
Branches executed:100.00% of 8
Taken at least once:100.00% of 8
No calls

Function 'playCard'
Lines executed:71.43% of 14
Branches executed:100.00% of 10
Taken at least once:50.00% of 10
No calls

Function 'buyCard'
Lines executed:0.00% of 13
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
No calls

Function 'numHandCards'
Lines executed:0.00% of 1
No branches
No calls

Function 'handCard'
Lines executed:100.00% of 2
No branches
No calls

Function 'supplyCount'
Lines executed:100.00% of 1
No branches
No calls

Function 'fullDeckCount'
Lines executed:0.00% of 11
Branches executed:0.00% of 12
Taken at least once:0.00% of 12
No calls

Function 'whoseTurn'
Lines executed:100.00% of 1
No branches
No calls

Function 'endTurn'
Lines executed:0.00% of 22
Branches executed:0.00% of 6
Taken at least once:0.00% of 6
No calls

Function 'isGameOver'
Lines executed:83.33% of 12
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

Function 'scoreFor'
Lines executed:37.10% of 62
Branches executed:71.43% of 42
Taken at least once:45.24% of 42
No calls

Function 'getWinners'
Lines executed:0.00% of 33
Branches executed:0.00% of 22
Taken at least once:0.00% of 22
No calls

Function 'drawCard'
Lines executed:70.83% of 24
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'getCost'
Lines executed:20.00% of 30
Branches executed:100.00% of 28
Taken at least once:14.29% of 28
No calls

Function 'cardEffect'
Lines executed:21.72% of 290
Branches executed:36.68% of 199
Taken at least once:18.59% of 199
No calls

Function 'discardCard'
Lines executed:86.67% of 15
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'gainCard'
Lines executed:73.33% of 15
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls

Function 'updateCoins'
Lines executed:71.43% of 14
Branches executed:100.00% of 8
Taken at least once:75.00% of 8
No calls

File 'dominion.c'
Lines executed:39.79% of 676
Branches executed:55.40% of 417
Taken at least once:32.85% of 417
No calls
dominion.c:creating 'dominion.c.gcov'

Function 'main'
Lines executed:82.09% of 67
Branches executed:84.62% of 26
Taken at least once:42.31% of 26
No calls

Function 'initTestGame'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyDeck'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
No calls

Function 'emptyPlayedCards'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyDiscard'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyHand'
Lines executed:100.00% of 5
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
No calls

Function 'setNewHandCount'
Lines executed:100.00% of 2
No branches
No calls

Function 'setAtHandPos'
Lines executed:100.00% of 2
No branches
No calls

File 'bug1unittest.c'
Lines executed:82.00% of 100
Branches executed:88.89% of 36
Taken at least once:50.00% of 36
No calls
bug1unittest.c:creating 'bug1unittest.c.gcov'

Function 'main'
Lines executed:84.75% of 59
Branches executed:81.82% of 22
Taken at least once:40.91% of 22
No calls

Function 'initTestGame'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyDeck'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
No calls

Function 'emptyDiscard'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyHand'
Lines executed:100.00% of 5
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
No calls

Function 'setNewHandCount'
Lines executed:100.00% of 2
No branches
No calls

Function 'setAtHandPos'
Lines executed:100.00% of 2
No branches
No calls

File 'bug1b_unittest.c'
Lines executed:84.88% of 86
Branches executed:86.67% of 30
Taken at least once:50.00% of 30
No calls
bug1b_unittest.c:creating 'bug1b_unittest.c.gcov'

Function 'assertMineCard'
Lines executed:60.00% of 5
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'main'
Lines executed:100.00% of 27
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'bug2unittest.c'
Lines executed:93.75% of 32
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls
bug2unittest.c:creating 'bug2unittest.c.gcov'

Function 'assertRemodelCard'
Lines executed:60.00% of 5
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'main'
Lines executed:100.00% of 27
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'bug3unittest.c'
Lines executed:93.75% of 32
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls
bug3unittest.c:creating 'bug3unittest.c.gcov'

Function 'assertGameOver'
Lines executed:60.00% of 5
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'main'
Lines executed:100.00% of 16
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
No calls

File 'bug4unittest.c'
Lines executed:90.48% of 21
Branches executed:100.00% of 6
Taken at least once:66.67% of 6
No calls
bug4unittest.c:creating 'bug4unittest.c.gcov'

Function 'assertScoreFor'
Lines executed:80.00% of 5
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'calculateScore'
Lines executed:37.10% of 62
Branches executed:71.43% of 42
Taken at least once:45.24% of 42
No calls

Function 'main'
Lines executed:100.00% of 13
No branches
No calls

File 'bug5unittest.c'
Lines executed:50.00% of 80
Branches executed:72.73% of 44
Taken at least once:45.45% of 44
No calls
bug5unittest.c:creating 'bug5unittest.c.gcov'

Function 'main'
Lines executed:100.00% of 18
No branches
No calls

File 'bug6unittest.c'
Lines executed:100.00% of 18
No branches
No calls
bug6unittest.c:creating 'bug6unittest.c.gcov'

Function 'main'
Lines executed:100.00% of 33
No branches
No calls

Function 'initTestGame'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyDeck'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
No calls

Function 'emptyPlayedCards'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyDiscard'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyHand'
Lines executed:100.00% of 5
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
No calls

Function 'setNewHandCount'
Lines executed:100.00% of 2
No branches
No calls

Function 'setAtHandPos'
Lines executed:100.00% of 2
No branches
No calls

Function 'subTestTribute'
Lines executed:100.00% of 26
No branches
No calls

Function 'runAsserts'
Lines executed:36.45% of 107
Branches executed:57.14% of 98
Taken at least once:29.59% of 98
No calls

File 'bug7unittest.c'
Lines executed:62.81% of 199
Branches executed:61.11% of 108
Taken at least once:33.33% of 108
No calls
bug7unittest.c:creating 'bug7unittest.c.gcov'

Function 'assertCoins'
Lines executed:80.00% of 5
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'main'
Lines executed:100.00% of 19
No branches
No calls

File 'bug8unittest.c'
Lines executed:95.83% of 24
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls
bug8unittest.c:creating 'bug8unittest.c.gcov'

Function 'main'
Lines executed:100.00% of 28
No branches
No calls

Function 'initTestGame'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyDeck'
Lines executed:100.00% of 6
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
No calls

Function 'emptyPlayedCards'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyDiscard'
Lines executed:66.67% of 6
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
No calls

Function 'emptyHand'
Lines executed:100.00% of 5
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
No calls

Function 'setNewHandCount'
Lines executed:100.00% of 2
No branches
No calls

Function 'setAtHandPos'
Lines executed:100.00% of 2
No branches
No calls

Function 'subTestTribute'
Lines executed:100.00% of 26
No branches
No calls

Function 'runAsserts'
Lines executed:36.45% of 107
Branches executed:57.14% of 98
Taken at least once:29.59% of 98
No calls

File 'bug9unittest.c'
Lines executed:61.86% of 194
Branches executed:61.11% of 108
Taken at least once:33.33% of 108
No calls
bug9unittest.c:creating 'bug9unittest.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:10
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 392 returned 100% blocks executed 85%
        -:    8:int compare(const void* a, const void* b) {
      392:    9:    if (*(int*)a > *(int*)b)
branch  0 taken 0%
branch  1 taken 100%
    #####:   10:        return 1;
      392:   11:    if (*(int*)a < *(int*)b)
branch  0 taken 36%
branch  1 taken 64%
      140:   12:        return -1;
      252:   13:    return 0;
      392:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
        -:   16:struct gameState* newGame() {
    #####:   17:    struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:    return g;
        -:   19:}
        -:   20:
function kingdomCards called 2 returned 100% blocks executed 100%
        -:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:                  int k8, int k9, int k10) {
        2:   23:    int* k = malloc(10 * sizeof(int));
        2:   24:    k[0] = k1;
        2:   25:    k[1] = k2;
        2:   26:    k[2] = k3;
        2:   27:    k[3] = k4;
        2:   28:    k[4] = k5;
        2:   29:    k[5] = k6;
        2:   30:    k[6] = k7;
        2:   31:    k[7] = k8;
        2:   32:    k[8] = k9;
        2:   33:    k[9] = k10;
        2:   34:    return k;
        -:   35:}
        -:   36:
function initializeGame called 14 returned 100% blocks executed 87%
        -:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:                   struct gameState *state) {
        -:   39:    int i;
        -:   40:    int j;
        -:   41:    int it;
        -:   42:
        -:   43:    //set up random number generator
       14:   44:    SelectStream(1);
       14:   45:    PutSeed((long)randomSeed);
        -:   46:
        -:   47:    //check number of players
       28:   48:    if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:   49:    {
    #####:   50:        return -1;
        -:   51:    }
        -:   52:
        -:   53:    //set number of players
       14:   54:    state->numPlayers = numPlayers;
        -:   55:
        -:   56:    //check selected kingdom cards are different
      308:   57:    for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9%
        -:   58:    {
     3080:   59:        for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9%
        -:   60:        {
     2660:   61:            if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90%
branch  1 taken 10%
branch  2 taken 0%
branch  3 taken 100%
        -:   62:            {
    #####:   63:                return -1;
        -:   64:            }
     1400:   65:        }
      140:   66:    }
        -:   67:
        -:   68:
        -:   69:    //initialize supply
        -:   70:    ///////////////////////////////
        -:   71:
        -:   72:    //set number of Curse cards
       14:   73:    if (numPlayers == 2)
branch  0 taken 100%
branch  1 taken 0%
        -:   74:    {
       14:   75:        state->supplyCount[curse] = 10;
       14:   76:    }
    #####:   77:    else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
        -:   78:    {
    #####:   79:        state->supplyCount[curse] = 20;
    #####:   80:    }
        -:   81:    else
        -:   82:    {
    #####:   83:        state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:    //set number of Victory cards
       14:   87:    if (numPlayers == 2)
branch  0 taken 100%
branch  1 taken 0%
        -:   88:    {
       14:   89:        state->supplyCount[estate] = 8;
       14:   90:        state->supplyCount[duchy] = 8;
       14:   91:        state->supplyCount[province] = 8;
       14:   92:    }
        -:   93:    else
        -:   94:    {
    #####:   95:        state->supplyCount[estate] = 12;
    #####:   96:        state->supplyCount[duchy] = 12;
    #####:   97:        state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:    //set number of Treasure cards
       14:  101:    state->supplyCount[copper] = 60 - (7 * numPlayers);
       14:  102:    state->supplyCount[silver] = 40;
       14:  103:    state->supplyCount[gold] = 30;
        -:  104:
        -:  105:    //set number of Kingdom cards
      588:  106:    for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5%
        -:  107:    {
     5010:  108:        for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 93%
branch  1 taken 7%
        -:  109:        {
     2337:  110:            if (kingdomCards[j] == i)
branch  0 taken 5%
branch  1 taken 95%
        -:  111:            {
        -:  112:                //check if card is a 'Victory' Kingdom card
      221:  113:                if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 97%
branch  1 taken 3%
branch  2 taken 13%
branch  3 taken 87%
        -:  114:                {
       17:  115:                    if (numPlayers == 2) {
branch  0 taken 100%
branch  1 taken 0%
       17:  116:                        state->supplyCount[i] = 8;
       17:  117:                    }
        -:  118:                    else {
    #####:  119:                        state->supplyCount[i] = 12;
        -:  120:                    }
       17:  121:                }
        -:  122:                else
        -:  123:                {
       95:  124:                    state->supplyCount[i] = 10;
        -:  125:                }
      112:  126:                break;
        -:  127:            }
        -:  128:            else    //card is not in the set choosen for the game
        -:  129:            {
     2225:  130:                state->supplyCount[i] = -1;
        -:  131:            }
     2225:  132:        }
        -:  133:
      280:  134:    }
        -:  135:
        -:  136:    ////////////////////////
        -:  137:    //supply intilization complete
        -:  138:
        -:  139:    //set player decks
       84:  140:    for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33%
        -:  141:    {
       28:  142:        state->deckCount[i] = 0;
      224:  143:        for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25%
        -:  144:        {
       84:  145:            state->deck[i][j] = estate;
       84:  146:            state->deckCount[i]++;
       84:  147:        }
      448:  148:        for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13%
        -:  149:        {
      196:  150:            state->deck[i][j] = copper;
      196:  151:            state->deckCount[i]++;
      196:  152:        }
       28:  153:    }
        -:  154:
        -:  155:    //shuffle player decks
       84:  156:    for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33%
        -:  157:    {
       28:  158:        if ( shuffle(i, state) < 0 )
branch  0 taken 0%
branch  1 taken 100%
        -:  159:        {
    #####:  160:            return -1;
        -:  161:        }
       28:  162:    }
        -:  163:
        -:  164:    //draw player hands
       84:  165:    for (i = 0; i < numPlayers; i++)
branch  0 taken 67%
branch  1 taken 33%
        -:  166:    {
        -:  167:        //initialize hand size to zero
       28:  168:        state->handCount[i] = 0;
       28:  169:        state->discardCount[i] = 0;
        -:  170:        //draw 5 cards
        -:  171:        // for (j = 0; j < 5; j++)
        -:  172:        //	{
        -:  173:        //	  drawCard(i, state);
        -:  174:        //	}
       28:  175:    }
        -:  176:
        -:  177:    //set embargo tokens to 0 for all supply piles
      784:  178:    for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4%
        -:  179:    {
      378:  180:        state->embargoTokens[i] = 0;
      378:  181:    }
        -:  182:
        -:  183:    //initialize first player's turn
       14:  184:    state->outpostPlayed = 0;
       14:  185:    state->phase = 0;
       14:  186:    state->numActions = 1;
       14:  187:    state->numBuys = 1;
       14:  188:    state->playedCardCount = 0;
       14:  189:    state->whoseTurn = 0;
       14:  190:    state->handCount[state->whoseTurn] = 0;
        -:  191:    //int it; move to top
        -:  192:
        -:  193:    //Moved draw cards to here, only drawing at the start of a turn
      168:  194:    for (it = 0; it < 5; it++) {
branch  0 taken 83%
branch  1 taken 17%
       70:  195:        drawCard(state->whoseTurn, state);
       70:  196:    }
        -:  197:
       14:  198:    updateCoins(state->whoseTurn, state, 0);
        -:  199:
       14:  200:    return 0;
       14:  201:}
        -:  202:
function shuffle called 34 returned 100% blocks executed 100%
        -:  203:int shuffle(int player, struct gameState *state) {
        -:  204:
        -:  205:
        -:  206:    int newDeck[MAX_DECK];
       34:  207:    int newDeckPos = 0;
        -:  208:    int card;
        -:  209:    int i;
        -:  210:
       34:  211:    if (state->deckCount[player] < 1)
branch  0 taken 18%
branch  1 taken 82%
        6:  212:        return -1;
       28:  213:    qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  214:    /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  215:
      616:  216:    while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9%
      280:  217:        card = floor(Random() * state->deckCount[player]);
      280:  218:        newDeck[newDeckPos] = state->deck[player][card];
      280:  219:        newDeckPos++;
     1812:  220:        for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 69%
branch  1 taken 31%
      626:  221:            state->deck[player][i] = state->deck[player][i+1];
      626:  222:        }
      280:  223:        state->deckCount[player]--;
        -:  224:    }
      616:  225:    for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9%
      280:  226:        state->deck[player][i] = newDeck[i];
      280:  227:        state->deckCount[player]++;
      280:  228:    }
        -:  229:
       28:  230:    return 0;
       34:  231:}
        -:  232:
function playCard called 1 returned 100% blocks executed 66%
        -:  233:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  234:{
        -:  235:    int card;
        1:  236:    int coin_bonus = 0; 		//tracks coins gain from actions
        -:  237:
        -:  238:    //check if it is the right phase
        1:  239:    if (state->phase != 0)
branch  0 taken 0%
branch  1 taken 100%
        -:  240:    {
    #####:  241:        return -1;
        -:  242:    }
        -:  243:
        -:  244:    //check if player has enough actions
        1:  245:    if ( state->numActions < 1 )
branch  0 taken 0%
branch  1 taken 100%
        -:  246:    {
    #####:  247:        return -1;
        -:  248:    }
        -:  249:
        -:  250:    //get card played
        1:  251:    card = handCard(handPos, state);
        -:  252:
        -:  253:    //check if selected card is an action
        2:  254:    if ( card < adventurer || card > treasure_map )
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:  255:    {
    #####:  256:        return -1;
        -:  257:    }
        -:  258:
        -:  259:    //play card
        1:  260:    if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
branch  0 taken 0%
branch  1 taken 100%
        -:  261:    {
    #####:  262:        return -1;
        -:  263:    }
        -:  264:
        -:  265:    //reduce number of actions
        1:  266:    state->numActions--;
        -:  267:
        -:  268:    //update coins (Treasure cards may be added with card draws)
        1:  269:    updateCoins(state->whoseTurn, state, coin_bonus);
        -:  270:
        1:  271:    return 0;
        1:  272:}
        -:  273:
function buyCard called 0 returned 0% blocks executed 0%
        -:  274:int buyCard(int supplyPos, struct gameState *state) {
        -:  275:    int who;
        -:  276:    if (DEBUG) {
        -:  277:        printf("Entering buyCard...\n");
        -:  278:    }
        -:  279:
        -:  280:    // I don't know what to do about the phase thing.
        -:  281:
    #####:  282:    who = state->whoseTurn;
        -:  283:
    #####:  284:    if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  285:        if (DEBUG)
        -:  286:            printf("You do not have any buys left\n");
    #####:  287:        return -1;
    #####:  288:    } else if (supplyCount(supplyPos, state) <1) {
branch  0 never executed
branch  1 never executed
        -:  289:        if (DEBUG)
        -:  290:            printf("There are not any of that type of card left\n");
    #####:  291:        return -1;
    #####:  292:    } else if (state->coins < getCost(supplyPos)) {
branch  0 never executed
branch  1 never executed
        -:  293:        if (DEBUG)
        -:  294:            printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:        return -1;
        -:  296:    } else {
    #####:  297:        state->phase=1;
        -:  298:        //state->supplyCount[supplyPos]--;
    #####:  299:        gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  300:
    #####:  301:        state->coins = (state->coins) - (getCost(supplyPos));
    #####:  302:        state->numBuys--;
        -:  303:        if (DEBUG)
        -:  304:            printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  305:    }
        -:  306:
        -:  307:    //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  308:    //state->discardCount[who]++;
        -:  309:
    #####:  310:    return 0;
    #####:  311:}
        -:  312:
function numHandCards called 0 returned 0% blocks executed 0%
        -:  313:int numHandCards(struct gameState *state) {
    #####:  314:    return state->handCount[ whoseTurn(state) ];
        -:  315:}
        -:  316:
function handCard called 1 returned 100% blocks executed 100%
        -:  317:int handCard(int handPos, struct gameState *state) {
        1:  318:    int currentPlayer = whoseTurn(state);
        1:  319:    return state->hand[currentPlayer][handPos];
        -:  320:}
        -:  321:
function supplyCount called 5 returned 100% blocks executed 100%
        -:  322:int supplyCount(int card, struct gameState *state) {
        5:  323:    return state->supplyCount[card];
        -:  324:}
        -:  325:
function fullDeckCount called 0 returned 0% blocks executed 0%
        -:  326:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  327:    int i;
    #####:  328:    int count = 0;
        -:  329:
    #####:  330:    for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  331:    {
    #####:  332:        if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
    #####:  333:    }
        -:  334:
    #####:  335:    for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  336:    {
    #####:  337:        if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
    #####:  338:    }
        -:  339:
    #####:  340:    for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  341:    {
    #####:  342:        if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
    #####:  343:    }
        -:  344:
    #####:  345:    return count;
        -:  346:}
        -:  347:
function whoseTurn called 13 returned 100% blocks executed 100%
        -:  348:int whoseTurn(struct gameState *state) {
       13:  349:    return state->whoseTurn;
        -:  350:}
        -:  351:
function endTurn called 0 returned 0% blocks executed 0%
        -:  352:int endTurn(struct gameState *state) {
        -:  353:    int k;
        -:  354:    int i;
    #####:  355:    int currentPlayer = whoseTurn(state);
        -:  356:
        -:  357:    //Discard hand
    #####:  358:    for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  359:        state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  360:        state->hand[currentPlayer][i] = -1;//Set card to -1
    #####:  361:    }
    #####:  362:    state->handCount[currentPlayer] = 0;//Reset hand count
        -:  363:
        -:  364:    //Code for determining the player
    #####:  365:    if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
    #####:  366:        state->whoseTurn = currentPlayer + 1;//Still safe to increment
    #####:  367:    }
        -:  368:    else {
    #####:  369:        state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  370:    }
        -:  371:
    #####:  372:    state->outpostPlayed = 0;
    #####:  373:    state->phase = 0;
    #####:  374:    state->numActions = 1;
    #####:  375:    state->coins = 0;
    #####:  376:    state->numBuys = 1;
    #####:  377:    state->playedCardCount = 0;
    #####:  378:    state->handCount[state->whoseTurn] = 0;
        -:  379:
        -:  380:    //int k; move to top
        -:  381:    //Next player draws hand
    #####:  382:    for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
    #####:  383:        drawCard(state->whoseTurn, state);//Draw a card
    #####:  384:    }
        -:  385:
        -:  386:    //Update money
    #####:  387:    updateCoins(state->whoseTurn, state, 0);
        -:  388:
    #####:  389:    return 0;
        -:  390:}
        -:  391:
function isGameOver called 1 returned 100% blocks executed 84%
        -:  392:int isGameOver(struct gameState *state) {
        -:  393:    int i;
        -:  394:    int j;
        -:  395:
        -:  396:    //if stack of Province cards is empty, the game ends
        1:  397:    if (state->supplyCount[province] == 0)
branch  0 taken 0%
branch  1 taken 100%
        -:  398:    {
    #####:  399:        return 1;
        -:  400:    }
        -:  401:
        -:  402:    //if three supply pile are at 0, the game ends
        1:  403:    j = 0;
       52:  404:    for (i = 0; i < 25; i++)
branch  0 taken 96%
branch  1 taken 4%
        -:  405:    {
       25:  406:        if (state->supplyCount[i] == 0)
branch  0 taken 4%
branch  1 taken 96%
        -:  407:        {
        1:  408:            j++;
        1:  409:        }
       25:  410:    }
        1:  411:    if ( j >= 3)
branch  0 taken 0%
branch  1 taken 100%
        -:  412:    {
    #####:  413:        return 1;
        -:  414:    }
        -:  415:
        1:  416:    return 0;
        1:  417:}
        -:  418:
function scoreFor called 1 returned 100% blocks executed 52%
        -:  419:int scoreFor (int player, struct gameState *state) {
        -:  420:
        -:  421:    int i;
        1:  422:    int score = 0;
        -:  423:    //score from hand
       12:  424:    for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17%
        -:  425:    {
        5:  426:        if (state->hand[player][i] == curse) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  427:            score = score - 1;
    #####:  428:        };
        5:  429:        if (state->hand[player][i] == estate) {
branch  0 taken 20%
branch  1 taken 80%
        1:  430:            score = score + 1;
        1:  431:        };
        5:  432:        if (state->hand[player][i] == duchy) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  433:            score = score + 3;
    #####:  434:        };
        5:  435:        if (state->hand[player][i] == province) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  436:            score = score + 6;
    #####:  437:        };
        5:  438:        if (state->hand[player][i] == great_hall) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  439:            score = score + 1;
    #####:  440:        };
        5:  441:        if (state->hand[player][i] == gardens) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  442:            score = score + ( fullDeckCount(player, 0, state) / 10 );
    #####:  443:        };
        5:  444:    }
        -:  445:
        -:  446:    //score from discard
        2:  447:    for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 0%
branch  1 taken 100%
        -:  448:    {
    #####:  449:        if (state->discard[player][i] == curse) {
branch  0 never executed
branch  1 never executed
    #####:  450:            score = score - 1;
    #####:  451:        };
    #####:  452:        if (state->discard[player][i] == estate) {
branch  0 never executed
branch  1 never executed
    #####:  453:            score = score + 1;
    #####:  454:        };
    #####:  455:        if (state->discard[player][i] == duchy) {
branch  0 never executed
branch  1 never executed
    #####:  456:            score = score + 3;
    #####:  457:        };
    #####:  458:        if (state->discard[player][i] == province) {
branch  0 never executed
branch  1 never executed
    #####:  459:            score = score + 6;
    #####:  460:        };
    #####:  461:        if (state->discard[player][i] == great_hall) {
branch  0 never executed
branch  1 never executed
    #####:  462:            score = score + 1;
    #####:  463:        };
    #####:  464:        if (state->discard[player][i] == gardens) {
branch  0 never executed
branch  1 never executed
    #####:  465:            score = score + ( fullDeckCount(player, 0, state) / 10 );
    #####:  466:        };
    #####:  467:    }
        -:  468:
        -:  469:    //score from deck
       12:  470:    for (i = 0; i < state->deckCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17%
        -:  471:    {
        5:  472:        if (state->deck[player][i] == curse) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  473:            score = score - 1;
    #####:  474:        };
        5:  475:        if (state->deck[player][i] == estate) {
branch  0 taken 40%
branch  1 taken 60%
        2:  476:            score = score + 1;
        2:  477:        };
        5:  478:        if (state->deck[player][i] == duchy) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  479:            score = score + 3;
    #####:  480:        };
        5:  481:        if (state->deck[player][i] == province) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  482:            score = score + 6;
    #####:  483:        };
        5:  484:        if (state->deck[player][i] == great_hall) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  485:            score = score + 1;
    #####:  486:        };
        5:  487:        if (state->deck[player][i] == gardens) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  488:            score = score + ( fullDeckCount(player, 0, state) / 10 );
    #####:  489:        };
        5:  490:    }
        -:  491:
        1:  492:    return score;
        -:  493:}
        -:  494:
function getWinners called 0 returned 0% blocks executed 0%
        -:  495:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  496:    int i;
        -:  497:    int j;
        -:  498:    int highScore;
        -:  499:    int currentPlayer;
        -:  500:
        -:  501:    //get score for each player
    #####:  502:    for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  503:    {
        -:  504:        //set unused player scores to -9999
    #####:  505:        if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  506:        {
    #####:  507:            players[i] = -9999;
    #####:  508:        }
        -:  509:        else
        -:  510:        {
    #####:  511:            players[i] = scoreFor (i, state);
        -:  512:        }
    #####:  513:    }
        -:  514:
        -:  515:    //find highest score
    #####:  516:    j = 0;
    #####:  517:    for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  518:    {
    #####:  519:        if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  520:        {
    #####:  521:            j = i;
    #####:  522:        }
    #####:  523:    }
    #####:  524:    highScore = players[j];
        -:  525:
        -:  526:    //add 1 to players who had less turns
    #####:  527:    currentPlayer = whoseTurn(state);
    #####:  528:    for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  529:    {
    #####:  530:        if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  531:        {
    #####:  532:            players[i]++;
    #####:  533:        }
    #####:  534:    }
        -:  535:
        -:  536:    //find new highest score
    #####:  537:    j = 0;
    #####:  538:    for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  539:    {
    #####:  540:        if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  541:        {
    #####:  542:            j = i;
    #####:  543:        }
    #####:  544:    }
    #####:  545:    highScore = players[j];
        -:  546:
        -:  547:    //set winners in array to 1 and rest to 0
    #####:  548:    for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  549:    {
    #####:  550:        if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  551:        {
    #####:  552:            players[i] = 1;
    #####:  553:        }
        -:  554:        else
        -:  555:        {
    #####:  556:            players[i] = 0;
        -:  557:        }
    #####:  558:    }
        -:  559:
    #####:  560:    return 0;
        -:  561:}
        -:  562:
function drawCard called 76 returned 100% blocks executed 75%
        -:  563:int drawCard(int player, struct gameState *state)
        -:  564:{   int count;
        -:  565:    int deckCounter;
       76:  566:    if (state->deckCount[player] <= 0) { //Deck is empty
branch  0 taken 8%
branch  1 taken 92%
        -:  567:
        -:  568:        //Step 1 Shuffle the discard pile back into a deck
        -:  569:        int i;
        -:  570:        //Move discard to deck
       12:  571:        for (i = 0; i < state->discardCount[player]; i++) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  572:            state->deck[player][i] = state->discard[player][i];
    #####:  573:            state->discard[player][i] = -1;
    #####:  574:        }
        -:  575:
        6:  576:        state->deckCount[player] = state->discardCount[player];
        6:  577:        state->discardCount[player] = 0;//Reset discard
        -:  578:
        -:  579:        //Shufffle the deck
        6:  580:        shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  581:
        -:  582:        if (DEBUG) { //Debug statements
        -:  583:            printf("Deck count now: %d\n", state->deckCount[player]);
        -:  584:        }
        -:  585:
        6:  586:        state->discardCount[player] = 0;
        -:  587:
        -:  588:        //Step 2 Draw Card
        6:  589:        count = state->handCount[player];//Get current player's hand count
        -:  590:
        -:  591:        if (DEBUG) { //Debug statements
        -:  592:            printf("Current hand count: %d\n", count);
        -:  593:        }
        -:  594:
        6:  595:        deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  596:
        6:  597:        if (deckCounter == 0)
branch  0 taken 100%
branch  1 taken 0%
        6:  598:            return -1;
        -:  599:
    #####:  600:        state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  601:        state->deckCount[player]--;
    #####:  602:        state->handCount[player]++;//Increment hand count
    #####:  603:    }
        -:  604:
        -:  605:    else {
       70:  606:        int count = state->handCount[player];//Get current hand count for player
        -:  607:        int deckCounter;
        -:  608:        if (DEBUG) { //Debug statements
        -:  609:            printf("Current hand count: %d\n", count);
        -:  610:        }
        -:  611:
       70:  612:        deckCounter = state->deckCount[player];//Create holder for the deck count
       70:  613:        state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       70:  614:        state->deckCount[player]--;
       70:  615:        state->handCount[player]++;//Increment hand count
        -:  616:    }
        -:  617:
       70:  618:    return 0;
       76:  619:}
        -:  620:
function getCost called 8 returned 100% blocks executed 22%
        -:  621:int getCost(int cardNumber)
        -:  622:{
        8:  623:    switch( cardNumber )
branch  0 taken 0%
branch  1 taken 13%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 50%
branch  5 taken 13%
branch  6 taken 25%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
branch 21 taken 0%
branch 22 taken 0%
branch 23 taken 0%
branch 24 taken 0%
branch 25 taken 0%
branch 26 taken 0%
branch 27 taken 0%
        -:  624:    {
        -:  625:    case curse:
    #####:  626:        return 0;
        -:  627:    case estate:
        1:  628:        return 2;
        -:  629:    case duchy:
    #####:  630:        return 5;
        -:  631:    case province:
    #####:  632:        return 8;
        -:  633:    case copper:
        4:  634:        return 0;
        -:  635:    case silver:
        1:  636:        return 3;
        -:  637:    case gold:
        2:  638:        return 6;
        -:  639:    case adventurer:
    #####:  640:        return 6;
        -:  641:    case council_room:
    #####:  642:        return 5;
        -:  643:    case feast:
    #####:  644:        return 4;
        -:  645:    case gardens:
    #####:  646:        return 4;
        -:  647:    case mine:
    #####:  648:        return 5;
        -:  649:    case remodel:
    #####:  650:        return 4;
        -:  651:    case smithy:
    #####:  652:        return 4;
        -:  653:    case village:
    #####:  654:        return 3;
        -:  655:    case baron:
    #####:  656:        return 4;
        -:  657:    case great_hall:
    #####:  658:        return 3;
        -:  659:    case minion:
    #####:  660:        return 5;
        -:  661:    case steward:
    #####:  662:        return 3;
        -:  663:    case tribute:
    #####:  664:        return 5;
        -:  665:    case ambassador:
    #####:  666:        return 3;
        -:  667:    case cutpurse:
    #####:  668:        return 4;
        -:  669:    case embargo:
    #####:  670:        return 2;
        -:  671:    case outpost:
    #####:  672:        return 5;
        -:  673:    case salvager:
    #####:  674:        return 4;
        -:  675:    case sea_hag:
    #####:  676:        return 4;
        -:  677:    case treasure_map:
    #####:  678:        return 4;
        -:  679:    }
        -:  680:
    #####:  681:    return -1;
        8:  682:}
        -:  683:
function cardEffect called 12 returned 100% blocks executed 20%
        -:  684:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  685:{
        -:  686:    int i;
        -:  687:    int j;
        -:  688:    int k;
        -:  689:    int x;
        -:  690:    int index;
       12:  691:    int currentPlayer = whoseTurn(state);
       12:  692:    int nextPlayer = currentPlayer + 1;
        -:  693:
       12:  694:    int tributeRevealedCards[2] = {-1, -1};
        -:  695:    int temphand[MAX_HAND];// moved above the if statement
       12:  696:    int drawntreasure=0;
        -:  697:    int cardDrawn;
       12:  698:    int z = 0;// this is the counter for the temp hand
       12:  699:    if (nextPlayer > (state->numPlayers - 1)) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  700:        nextPlayer = 0;
    #####:  701:    }
        -:  702:
        -:  703:
        -:  704:    //uses switch to select card and perform actions
       12:  705:    switch( card )
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 17%
branch  5 taken 17%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 8%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 58%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  706:    {
        -:  707:    case adventurer:
    #####:  708:        while(drawntreasure<2) {
branch  0 never executed
branch  1 never executed
    #####:  709:            if (state->deckCount[currentPlayer] <1) { //if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  710:                shuffle(currentPlayer, state);
    #####:  711:            }
    #####:  712:            drawCard(currentPlayer, state);
    #####:  713:            cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  714:            if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  715:                drawntreasure++;
        -:  716:            else {
    #####:  717:                temphand[z]=cardDrawn;
    #####:  718:                state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  719:                z++;
        -:  720:            }
        -:  721:        }
    #####:  722:        while(z-1>=0) {
branch  0 never executed
branch  1 never executed
    #####:  723:            state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  724:            z=z-1;
        -:  725:        }
    #####:  726:        return 0;
        -:  727:
        -:  728:    case council_room:
        -:  729:        //+4 Cards
    #####:  730:        for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  731:        {
    #####:  732:            drawCard(currentPlayer, state);
    #####:  733:        }
        -:  734:
        -:  735:        //+1 Buy
    #####:  736:        state->numBuys++;
        -:  737:
        -:  738:        //Each other player draws a card
    #####:  739:        for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  740:        {
    #####:  741:            if ( i != currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  742:            {
    #####:  743:                drawCard(i, state);
    #####:  744:            }
    #####:  745:        }
        -:  746:
        -:  747:        //put played card in played card pile
    #####:  748:        discardCard(handPos, currentPlayer, state, 0);
        -:  749:
    #####:  750:        return 0;
        -:  751:
        -:  752:        case feast:
        -:  753:
        -:  754:            //gain card with cost up to 5
        -:  755:            //Backup hand
    #####:  756:            for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  757:                temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  758:                state->hand[currentPlayer][i] = -1;//Set to nothing
    #####:  759:            }
        -:  760:            //Backup hand
        -:  761:
        -:  762:            //Update Coins for Buy
    #####:  763:            updateCoins(currentPlayer, state, 5);
        -:  764:
    #####:  765:            x = 1;//Condition to loop on
    #####:  766:            while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  767:                if (supplyCount(choice1, state) <= 0) {
branch  0 never executed
branch  1 never executed
        -:  768:                    if (DEBUG)
        -:  769:                        printf("None of that card left, sorry!\n");
        -:  770:
        -:  771:                    if (DEBUG) {
        -:  772:                        printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  773:                    }
    #####:  774:                }
    #####:  775:                else if (state->coins < getCost(choice1)) {
branch  0 never executed
branch  1 never executed
        -:  776:
    #####:  777:                    printf("That card is too expensive!\n");
        -:  778:
        -:  779:                    if (DEBUG) {
        -:  780:                        printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  781:                    }
    #####:  782:                }
        -:  783:                else {
        -:  784:
        -:  785:                    if (DEBUG) {
        -:  786:                        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  787:                    }
        -:  788:
    #####:  789:                    gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  790:                    x = 0;//No more buying cards
        -:  791:
        -:  792:                    if (DEBUG) {
        -:  793:                        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  794:                    }
        -:  795:
        -:  796:                }
        -:  797:            }
        -:  798:
        -:  799:            //Reset Hand
    #####:  800:            for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  801:                state->hand[currentPlayer][i] = temphand[i];
    #####:  802:                temphand[i] = -1;
    #####:  803:            }
        -:  804:            //Reset Hand
        -:  805:
    #####:  806:        return 0;
        -:  807:
        -:  808:    case gardens:
    #####:  809:        return -1;
        -:  810:
        -:  811:    case mine:
        2:  812:        j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  813:
        4:  814:        if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:  815:        {
    #####:  816:            return -1;
        -:  817:        }
        -:  818:
        4:  819:        if (choice2 > treasure_map || choice2 < curse)
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:  820:        {
    #####:  821:            return -1;
        -:  822:        }
        -:  823:
        2:  824:        if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
branch  0 taken 50%
branch  1 taken 50%
        -:  825:        {
        1:  826:            return -1;
        -:  827:        }
        -:  828:
        1:  829:        gainCard(choice2, state, 2, currentPlayer);
        -:  830:
        -:  831:        //discard card from hand
        1:  832:        discardCard(handPos, currentPlayer, state, 0);
        -:  833:
        -:  834:        //discard trashed card
        4:  835:        for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 100%
branch  1 taken 0%
        -:  836:        {
        2:  837:            if (state->hand[currentPlayer][i] == j)
branch  0 taken 50%
branch  1 taken 50%
        -:  838:            {
        1:  839:                discardCard(i, currentPlayer, state, 0);
        1:  840:                break;
        -:  841:            }
        1:  842:        }
        -:  843:
        1:  844:        return 0;
        -:  845:
        -:  846:    case remodel:
        2:  847:        j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  848:
        2:  849:        if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
branch  0 taken 50%
branch  1 taken 50%
        -:  850:        {
        1:  851:            return -1;
        -:  852:        }
        -:  853:
        1:  854:        gainCard(choice2, state, 0, currentPlayer);
        -:  855:
        -:  856:        //discard card from hand
        1:  857:        discardCard(handPos, currentPlayer, state, 0);
        -:  858:
        -:  859:        //discard trashed card
        2:  860:        for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 taken 100%
branch  1 taken 0%
        -:  861:        {
        1:  862:            if (state->hand[currentPlayer][i] == j)
branch  0 taken 100%
branch  1 taken 0%
        -:  863:            {
        1:  864:                discardCard(i, currentPlayer, state, 0);
        1:  865:                break;
        -:  866:            }
    #####:  867:        }
        -:  868:
        -:  869:
        1:  870:        return 0;
        -:  871:
        -:  872:    case smithy:
        -:  873:        //+3 Cards
    #####:  874:        for (i = 0; i < 3; i++)
branch  0 never executed
branch  1 never executed
        -:  875:        {
    #####:  876:            drawCard(currentPlayer, state);
    #####:  877:        }
        -:  878:
        -:  879:        //discard card from hand
    #####:  880:        discardCard(handPos, currentPlayer, state, 0);
    #####:  881:        return 0;
        -:  882:
        -:  883:    case village:
        -:  884:        //+1 Card
    #####:  885:        drawCard(currentPlayer, state);
        -:  886:
        -:  887:        //+2 Actions
    #####:  888:        state->numActions = state->numActions + 2;
        -:  889:
        -:  890:        //discard played card from hand
    #####:  891:        discardCard(handPos, currentPlayer, state, 0);
    #####:  892:        return 0;
        -:  893:
        -:  894:    case baron:
        1:  895:        state->numBuys++;//Increase buys by 1!
        1:  896:        if (choice1 > 0) { //Boolean true or going to discard an estate
branch  0 taken 0%
branch  1 taken 100%
    #####:  897:            int p = 0;//Iterator for hand!
    #####:  898:            int card_not_discarded = 1;//Flag for discard set!
    #####:  899:            while(card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  900:                if (state->hand[currentPlayer][p] == estate) { //Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  901:                    updateCoins(currentPlayer, state, 4);//Add 4 coins to the amount of coins
    #####:  902:                    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  903:                    state->discardCount[currentPlayer]++;
    #####:  904:                    for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  905:                        state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
    #####:  906:                    }
    #####:  907:                    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  908:                    state->handCount[currentPlayer]--;
    #####:  909:                    card_not_discarded = 0;//Exit the loop
    #####:  910:                }
    #####:  911:                else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  912:                    if(DEBUG) {
        -:  913:                        printf("No estate cards in your hand, invalid choice\n");
        -:  914:                        printf("Must gain an estate if there are any\n");
        -:  915:                    }
    #####:  916:                    if (supplyCount(estate, state) > 0) {
branch  0 never executed
branch  1 never executed
    #####:  917:                        gainCard(estate, state, 0, currentPlayer);
        -:  918:
    #####:  919:                        state->supplyCount[estate]--;//Decrement estates
    #####:  920:                        if (supplyCount(estate, state) == 0) {
branch  0 never executed
branch  1 never executed
    #####:  921:                            isGameOver(state);
    #####:  922:                        }
    #####:  923:                    }
    #####:  924:                    card_not_discarded = 0;//Exit the loop
    #####:  925:                }
        -:  926:
        -:  927:                else {
    #####:  928:                    p++;//Next card
        -:  929:                }
        -:  930:            }
    #####:  931:        }
        -:  932:
        -:  933:        else {
        1:  934:            if (supplyCount(estate, state) > 0) {
branch  0 taken 100%
branch  1 taken 0%
        1:  935:                gainCard(estate, state, 0, currentPlayer);//Gain an estate
        -:  936:
        1:  937:                state->supplyCount[estate]--;//Decrement Estates
        1:  938:                if (supplyCount(estate, state) == 0) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  939:                    isGameOver(state);
    #####:  940:                }
        1:  941:            }
        -:  942:        }
        -:  943:
        -:  944:
        1:  945:        return 0;
        -:  946:
        -:  947:    case great_hall:
        -:  948:        //+1 Card
    #####:  949:        drawCard(currentPlayer, state);
        -:  950:
        -:  951:        //+1 Actions
    #####:  952:        state->numActions++;
        -:  953:
        -:  954:        //discard card from hand
    #####:  955:        discardCard(handPos, currentPlayer, state, 0);
    #####:  956:        return 0;
        -:  957:
        -:  958:    case minion:
        -:  959:        //+1 action
    #####:  960:        state->numActions++;
        -:  961:
        -:  962:        //discard card from hand
    #####:  963:        discardCard(handPos, currentPlayer, state, 0);
        -:  964:
    #####:  965:		if (choice1)
branch  0 never executed
branch  1 never executed
        -:  966:        {
    #####:  967:            state->coins = state->coins + 2;
    #####:  968:        }
    #####:  969:        else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  970:        {
        -:  971:            //discard hand
    #####:  972:            while(numHandCards(state) > 0)
branch  0 never executed
branch  1 never executed
        -:  973:            {
    #####:  974:                discardCard(handPos, currentPlayer, state, 0);
        -:  975:            }
        -:  976:
        -:  977:            //draw 4
    #####:  978:            for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  979:            {
    #####:  980:                drawCard(currentPlayer, state);
    #####:  981:            }
        -:  982:
        -:  983:            //other players discard hand and redraw if hand size > 4
    #####:  984:            for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  985:            {
    #####:  986:                if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  987:                {
    #####:  988:                    if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  989:                    {
        -:  990:                        //discard hand
    #####:  991:                        while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -:  992:                        {
    #####:  993:                            discardCard(handPos, i, state, 0);
        -:  994:                        }
        -:  995:
        -:  996:                        //draw 4
    #####:  997:                        for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -:  998:                        {
    #####:  999:                            drawCard(i, state);
    #####: 1000:                        }
    #####: 1001:                    }
    #####: 1002:                }
    #####: 1003:            }
        -: 1004:
    #####: 1005:        }
    #####: 1006:        return 0;
        -: 1007:
        -: 1008:    case steward:
    #####: 1009:        if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1010:        {
        -: 1011:            //+2 cards
    #####: 1012:            drawCard(currentPlayer, state);
    #####: 1013:            drawCard(currentPlayer, state);
    #####: 1014:        }
    #####: 1015:        else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1016:        {
        -: 1017:            //+2 coins
    #####: 1018:            state->coins = state->coins + 2;
    #####: 1019:        }
        -: 1020:        else
        -: 1021:        {
        -: 1022:            //trash 2 cards in hand
    #####: 1023:            discardCard(choice2, currentPlayer, state, 1);
    #####: 1024:            discardCard(choice3, currentPlayer, state, 1);
        -: 1025:        }
        -: 1026:
        -: 1027:        //discard card from hand
    #####: 1028:        discardCard(handPos, currentPlayer, state, 0);
    #####: 1029:        return 0;
        -: 1030:
        -: 1031:    case tribute:
        7: 1032:        if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 taken 0%
branch  1 taken 100%
    #####: 1033:            if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1034:                tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1035:                state->deckCount[nextPlayer]--;
    #####: 1036:            }
    #####: 1037:            else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1038:                tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1039:                state->discardCount[nextPlayer]--;
    #####: 1040:            }
        -: 1041:            else {
        -: 1042:                //No Card to Reveal
        -: 1043:                if (DEBUG) {
        -: 1044:                    printf("No cards to reveal\n");
        -: 1045:                }
        -: 1046:            }
    #####: 1047:        }
        -: 1048:
        -: 1049:        else {
        7: 1050:            if (state->deckCount[nextPlayer] == 0) {
branch  0 taken 0%
branch  1 taken 100%
    #####: 1051:                for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1052:                    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1053:                    state->deckCount[nextPlayer]++;
    #####: 1054:                    state->discard[nextPlayer][i] = -1;
    #####: 1055:                    state->discardCount[nextPlayer]--;
    #####: 1056:                }
        -: 1057:
    #####: 1058:                shuffle(nextPlayer,state);//Shuffle the deck
    #####: 1059:            }
        7: 1060:            tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        7: 1061:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        7: 1062:            state->deckCount[nextPlayer]--;
        7: 1063:            tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        7: 1064:            state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        7: 1065:            state->deckCount[nextPlayer]--;
        -: 1066:        }
        -: 1067:
        7: 1068:        if (tributeRevealedCards[0] == tributeRevealedCards[1]) { //If we have a duplicate card, just drop one
branch  0 taken 29%
branch  1 taken 71%
        2: 1069:            state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        2: 1070:            state->playedCardCount++;
        2: 1071:            tributeRevealedCards[1] = -1;
        2: 1072:        }
        -: 1073:
       56: 1074:        for (i = 0; i <= 2; i ++) {
branch  0 taken 75%
branch  1 taken 25%
       63: 1075:            if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 10%
branch  5 taken 90%
        2: 1076:                state->coins += 2;
        2: 1077:            }
        -: 1078:
       83: 1079:            else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) { //Victory Card Found
branch  0 taken 84%
branch  1 taken 16%
branch  2 taken 100%
branch  3 taken 0%
branch  4 taken 100%
branch  5 taken 0%
branch  6 taken 100%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 100%
        3: 1080:                drawCard(currentPlayer, state);
        3: 1081:                drawCard(currentPlayer, state);
        3: 1082:            }
        -: 1083:            else { //Action Card
       16: 1084:                state->numActions = state->numActions + 2;
        -: 1085:            }
       21: 1086:        }
        -: 1087:
        7: 1088:        return 0;
        -: 1089:
        -: 1090:    case ambassador:
    #####: 1091:        j = 0;		//used to check if player has enough cards to discard
        -: 1092:
    #####: 1093:        if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1094:        {
    #####: 1095:            return -1;
        -: 1096:        }
        -: 1097:
    #####: 1098:        if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1099:        {
    #####: 1100:            return -1;
        -: 1101:        }
        -: 1102:
    #####: 1103:        for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1104:        {
    #####: 1105:            if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1106:            {
    #####: 1107:                j++;
    #####: 1108:            }
    #####: 1109:        }
    #####: 1110:        if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1111:        {
    #####: 1112:            return -1;
        -: 1113:        }
        -: 1114:
        -: 1115:        if (DEBUG)
        -: 1116:            printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1117:
        -: 1118:        //increase supply count for choosen card by amount being discarded
    #####: 1119:        state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1120:
        -: 1121:        //each other player gains a copy of revealed card
    #####: 1122:        for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1123:        {
    #####: 1124:            if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1125:            {
    #####: 1126:                gainCard(state->hand[currentPlayer][choice1], state, 0, i);
    #####: 1127:            }
    #####: 1128:        }
        -: 1129:
        -: 1130:        //discard played card from hand
    #####: 1131:        discardCard(handPos, currentPlayer, state, 0);
        -: 1132:
        -: 1133:        //trash copies of cards returned to supply
    #####: 1134:        for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1135:        {
    #####: 1136:            for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1137:            {
    #####: 1138:                if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1139:                {
    #####: 1140:                    discardCard(i, currentPlayer, state, 1);
    #####: 1141:                    break;
        -: 1142:                }
    #####: 1143:            }
    #####: 1144:        }
        -: 1145:
    #####: 1146:        return 0;
        -: 1147:
        -: 1148:    case cutpurse:
        -: 1149:
    #####: 1150:        updateCoins(currentPlayer, state, 2);
    #####: 1151:        for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1152:        {
    #####: 1153:            if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1154:            {
    #####: 1155:                for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1156:                {
    #####: 1157:                    if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1158:                    {
    #####: 1159:                        discardCard(j, i, state, 0);
    #####: 1160:                        break;
        -: 1161:                    }
    #####: 1162:                    if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1163:                    {
    #####: 1164:                        for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1165:                        {
        -: 1166:                            if (DEBUG)
        -: 1167:                                printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
    #####: 1168:                        }
    #####: 1169:                        break;
        -: 1170:                    }
    #####: 1171:                }
        -: 1172:
    #####: 1173:            }
        -: 1174:
    #####: 1175:        }
        -: 1176:
        -: 1177:        //discard played card from hand
    #####: 1178:        discardCard(handPos, currentPlayer, state, 0);
        -: 1179:
    #####: 1180:        return 0;
        -: 1181:
        -: 1182:
        -: 1183:    case embargo:
        -: 1184:        //+2 Coins
    #####: 1185:        state->coins = state->coins + 2;
        -: 1186:
        -: 1187:        //see if selected pile is in play
    #####: 1188:        if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1189:        {
    #####: 1190:            return -1;
        -: 1191:        }
        -: 1192:
        -: 1193:        //add embargo token to selected supply pile
    #####: 1194:        state->embargoTokens[choice1]++;
        -: 1195:
        -: 1196:        //trash card
    #####: 1197:        discardCard(handPos, currentPlayer, state, 1);
    #####: 1198:        return 0;
        -: 1199:
        -: 1200:    case outpost:
        -: 1201:        //set outpost flag
    #####: 1202:        state->outpostPlayed++;
        -: 1203:
        -: 1204:        //discard card
    #####: 1205:        discardCard(handPos, currentPlayer, state, 0);
    #####: 1206:        return 0;
        -: 1207:
        -: 1208:    case salvager:
        -: 1209:        //+1 buy
    #####: 1210:        state->numBuys++;
        -: 1211:
    #####: 1212:        if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1213:        {
        -: 1214:            //gain coins equal to trashed card
    #####: 1215:            state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1216:            //trash card
    #####: 1217:            discardCard(choice1, currentPlayer, state, 1);
    #####: 1218:        }
        -: 1219:
        -: 1220:        //discard card
    #####: 1221:        discardCard(handPos, currentPlayer, state, 0);
    #####: 1222:        return 0;
        -: 1223:
        -: 1224:    case sea_hag:
    #####: 1225:        for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1226:            if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1227:                state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];
    #####: 1228:                state->deckCount[i]--;
    #####: 1229:                state->discardCount[i]++;
    #####: 1230:                state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
    #####: 1231:            }
    #####: 1232:        }
    #####: 1233:        return 0;
        -: 1234:
        -: 1235:    case treasure_map:
        -: 1236:        //search hand for another treasure_map
    #####: 1237:        index = -1;
    #####: 1238:        for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1239:        {
    #####: 1240:            if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1241:            {
    #####: 1242:                index = i;
    #####: 1243:                break;
        -: 1244:            }
    #####: 1245:        }
    #####: 1246:        if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1247:        {
        -: 1248:            //trash both treasure cards
    #####: 1249:            discardCard(handPos, currentPlayer, state, 1);
    #####: 1250:            discardCard(index, currentPlayer, state, 1);
        -: 1251:
        -: 1252:            //gain 4 Gold cards
    #####: 1253:            for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1254:            {
    #####: 1255:                gainCard(gold, state, 1, currentPlayer);
    #####: 1256:            }
        -: 1257:
        -: 1258:            //return success
    #####: 1259:            return 1;
        -: 1260:        }
        -: 1261:
        -: 1262:        //no second treasure_map found in hand
    #####: 1263:        return -1;
        -: 1264:    }
        -: 1265:
    #####: 1266:    return -1;
       12: 1267:}
        -: 1268:
function discardCard called 4 returned 100% blocks executed 90%
        -: 1269:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1270:{
        -: 1271:
        -: 1272:    //if card is not trashed, added to Played pile
        4: 1273:    if (trashFlag < 1)
branch  0 taken 100%
branch  1 taken 0%
        -: 1274:    {
        -: 1275:        //add card to played pile
        4: 1276:        state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
        4: 1277:        state->playedCardCount++;
        4: 1278:    }
        -: 1279:
        -: 1280:    //set played card to -1
        4: 1281:    state->hand[currentPlayer][handPos] = -1;
        -: 1282:
        -: 1283:    //remove card from player's hand
        4: 1284:    if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 50%
branch  1 taken 50%
        -: 1285:    {
        -: 1286:        //reduce number of cards in hand
        2: 1287:        state->handCount[currentPlayer]--;
        2: 1288:    }
        2: 1289:    else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0%
branch  1 taken 100%
        -: 1290:    {
        -: 1291:        //reduce number of cards in hand
    #####: 1292:        state->handCount[currentPlayer]--;
    #####: 1293:    }
        -: 1294:    else
        -: 1295:    {
        -: 1296:        //replace discarded card with last card in hand
        2: 1297:        state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1298:        //set last card to -1
        2: 1299:        state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1300:        //reduce number of cards in hand
        2: 1301:        state->handCount[currentPlayer]--;
        -: 1302:    }
        -: 1303:
        4: 1304:    return 0;
        -: 1305:}
        -: 1306:
function gainCard called 3 returned 100% blocks executed 81%
        -: 1307:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1308:{
        -: 1309:    //Note: supplyPos is enum of choosen card
        -: 1310:
        -: 1311:    //check if supply pile is empty (0) or card is not used in game (-1)
        3: 1312:    if ( supplyCount(supplyPos, state) < 1 )
branch  0 taken 0%
branch  1 taken 100%
        -: 1313:    {
    #####: 1314:        return -1;
        -: 1315:    }
        -: 1316:
        -: 1317:    //added card for [whoseTurn] current player:
        -: 1318:    // toFlag = 0 : add to discard
        -: 1319:    // toFlag = 1 : add to deck
        -: 1320:    // toFlag = 2 : add to hand
        -: 1321:
        3: 1322:    if (toFlag == 1)
branch  0 taken 0%
branch  1 taken 100%
        -: 1323:    {
    #####: 1324:        state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1325:        state->deckCount[player]++;
    #####: 1326:    }
        3: 1327:    else if (toFlag == 2)
branch  0 taken 33%
branch  1 taken 67%
        -: 1328:    {
        1: 1329:        state->hand[ player ][ state->handCount[player] ] = supplyPos;
        1: 1330:        state->handCount[player]++;
        1: 1331:    }
        -: 1332:    else
        -: 1333:    {
        2: 1334:        state->discard[player][ state->discardCount[player] ] = supplyPos;
        2: 1335:        state->discardCount[player]++;
        -: 1336:    }
        -: 1337:
        -: 1338:    //decrease number in supply pile
        3: 1339:    state->supplyCount[supplyPos]--;
        -: 1340:
        3: 1341:    return 0;
        3: 1342:}
        -: 1343:
function updateCoins called 25 returned 100% blocks executed 85%
        -: 1344:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1345:{
        -: 1346:    int i;
        -: 1347:
        -: 1348:    //reset coin count
       25: 1349:    state->coins = 0;
        -: 1350:
        -: 1351:    //add coins for each Treasure card in player's hand
      232: 1352:    for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 78%
branch  1 taken 22%
        -: 1353:    {
       91: 1354:        if (state->hand[player][i] == copper)
branch  0 taken 70%
branch  1 taken 30%
        -: 1355:        {
       64: 1356:            state->coins += 1;
       64: 1357:        }
       27: 1358:        else if (state->hand[player][i] == silver)
branch  0 taken 0%
branch  1 taken 100%
        -: 1359:        {
    #####: 1360:            state->coins += 2;
    #####: 1361:        }
       27: 1362:        else if (state->hand[player][i] == gold)
branch  0 taken 0%
branch  1 taken 100%
        -: 1363:        {
    #####: 1364:            state->coins += 3;
    #####: 1365:        }
       91: 1366:    }
        -: 1367:
        -: 1368:    //add bonus
       25: 1369:    state->coins += bonus;
        -: 1370:
       25: 1371:    return 0;
        -: 1372:}
        -: 1373:
        -: 1374:
        -: 1375://end of dominion.c
        -:    0:Source:bug1unittest.c
        -:    0:Graph:bug1unittest.gcno
        -:    0:Data:bug1unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*************************************************
        -:    2:* FileName: bug1unittest.c
        -:    3:* Author:	Glen Gougeon
        -:    4:* Class:	CS362 Software Engineering II
        -:    5:* Created:	11-29-2019
        -:    6:* Last Mod:	11-29-2019
        -:    7:* 
        -:    8:* Assignement: Final Project Part B/
        -:    9:*
        -:   10:* Description:	Unit Test for Bug 1: 
        -:   11:*				Mine Money to Trash only discards 
        -:   12:*
        -:   13:**************************************************/
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "interface.h"
        -:   22:#include "rngs.h"
        -:   23:
        -:   24:// TEST PROTO-TYPES
        -:   25:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game);
        -:   26:
        -:   27:// HELPER PROTOS-TYPES
        -:   28:void emptyDeck(int player, struct gameState* state);
        -:   29:void emptyPlayedCards(struct gameState* state);
        -:   30:void emptyDiscard(int player, struct gameState* state);
        -:   31:
        -:   32:// HAND RELATED PROTO-TYPES
        -:   33:void emptyHand(int player, struct gameState* dState);
        -:   34:void setNewHandCount(int player, struct gameState* state, int newHandSize);
        -:   35:void setAtHandPos(int player, struct gameState* state, int card, int handPos);
        -:   36:
function main called 1 returned 100% blocks executed 68%
        -:   37:int main()
        -:   38:{
        1:   39:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        1:   40:	printf("*** START Bug1 Unit Test: Mine Money to Trash Only Discards ***\n");
        1:   41:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        1:   42:	printf("Note* discardCard() broken. Where would test contents of discard..\n");
        1:   43:	printf("      I am testing against contents of playedCards instead.\n\n");
        -:   44:
        -:   45:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   46:	/* ** SETUP TEST SECTION ** */
        -:   47:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   48:
        1:   49:	int kingdomCards[10] = { adventurer, ambassador, baron, estate, tribute, minion, mine,  gardens, remodel, smithy };
        -:   50:
        -:   51:	struct gameState G;
        -:   52:	struct gameState backup;
        -:   53:
        1:   54:	int seed = 1;
        1:   55:	int numPlayers = 2;
        1:   56:	int currentPlayer = 0;
        1:   57:	int newHandSize = 2;
        1:   58:	int mine_index = 0; // handPos remodel
        1:   59:	int idxOfChoice1 = 1; // choice1 mine
        1:   60:	int moneyToGet = silver; // choice2 mine
        1:   61:	int blank = -1;
        1:   62:	int coinBonus = 0;
        -:   63:
        -:   64:	// initialize and set currentPlayer
        1:   65:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   66:	currentPlayer = G.whoseTurn;
        -:   67:
        -:   68:	// empty every deck currentPlayer has
        1:   69:	emptyDeck(currentPlayer, &G);
        1:   70:	emptyPlayedCards(&G); // req'd. b/c 'discardCard' is broken !!
        1:   71:	emptyDiscard(currentPlayer, &G);
        1:   72:	emptyHand(currentPlayer, &G);
        -:   73:
        -:   74:	// you will only have a copper in your hand
        1:   75:	setNewHandCount(currentPlayer, &G, newHandSize);
        -:   76:
        -:   77:	// place mine card in hand
        1:   78:	setAtHandPos(currentPlayer, &G, mine, mine_index);
        -:   79:
        -:   80:	// The only copper in the game is in currentPlayer's hand
        1:   81:	G.supplyCount[copper] = 0;
        -:   82:
        -:   83:	// The only silver in the game is THIS in supply
        1:   84:	G.supplyCount[silver] = 0;
        1:   85:	G.supplyCount[silver] = 1;
        -:   86:
        1:   87:	setAtHandPos(currentPlayer, &G, copper, idxOfChoice1);
        1:   88:	updateCoins(currentPlayer, &G, coinBonus);
        -:   89:
        -:   90:	/* BACK UP STATE BEFORE CALL */
        1:   91:	memset(&backup, '\0', sizeof(backup));
        1:   92:	backup = G;
        -:   93:	
        -:   94:	/* CALL TO MINE <-----------------------------------------------------*/
        1:   95:	cardEffect(mine, idxOfChoice1, moneyToGet, blank, &G, mine_index, &coinBonus);
        -:   96:
        -:   97:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   98:	/* ** ASSERTS SECTION ** */
        -:   99:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  100:
        -:  101:	/*	Assert that choice1(an index) is a different card, otherwise print that it
        -:  102:		is the same. */
        1:  103:	if(backup.hand[currentPlayer][idxOfChoice1] == G.hand[currentPlayer][idxOfChoice1])
branch  0 taken 0%
branch  1 taken 100%
        -:  104:	{
    #####:  105:		printf("Error Mine: choice1 is still the same but shouldn't be.\n\n");
    #####:  106:	}
        -:  107:
        -:  108:	/*	Assert if top of previous discard was not the same as choice1, and
        -:  109:	choice1 is found at the top of discard, print 'choice1 discarded
        -:  110:	not trashed'. */
        -:  111:
        -:  112:	//if (backup.discard[currentPlayer][backup.discardCount[currentPlayer] - 1] != copper)
        1:  113:	if (backup.playedCards[backup.playedCardCount - 1] != copper)
branch  0 taken 100%
branch  1 taken 0%
        -:  114:	{
        1:  115:		if (G.playedCards[G.playedCardCount - 1] == copper)
branch  0 taken 100%
branch  1 taken 0%
        -:  116:		{
        -:  117:			//printf("Error 'discardCard': should be discard .. but is playedCards array\n");
        1:  118:			printf("Error Mine: choice1 found in playedCards, but should be at top of trashPile.\n\n");
        1:  119:		}
        1:  120:	}
        -:  121:
        -:  122:	/*	Assert if top of previous discard was the same as choice1, and the
        -:  123:	top 2 cards in discard are both choice1, print 'choice1 discarded
        -:  124:	not trashed'. */
        -:  125:	//if (backup.discard[currentPlayer][backup.discardCount[currentPlayer] -1] == copper)
        -:  126:	//{
        -:  127:	//	if ((G.discard[currentPlayer][G.discardCount[currentPlayer] - 1] == copper) &&
        -:  128:	//	    (G.discard[currentPlayer][G.discardCount[currentPlayer] - 2] == copper))
        -:  129:	//	{
        -:  130:	//		printf("Error Mine: choice1 discarded not trashed.\n\n");
        -:  131:	//	}
        -:  132:	//}
        -:  133:
        1:  134:	if (backup.playedCards[backup.playedCardCount - 1] == copper)
branch  0 taken 0%
branch  1 taken 100%
        -:  135:	{
    #####:  136:		if ((G.playedCards[G.playedCardCount - 1] == copper) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  137:			(G.playedCards[G.playedCardCount - 2] == copper))
        -:  138:		{
        -:  139:			//printf("Error 'discardCard': should be discard .. but is playedCards array\n");
    #####:  140:			printf("Error Mine: choice1 found in playedCards NOT in trash.\n\n");
    #####:  141:		}
    #####:  142:	}
        -:  143:
        -:  144:	/*	Assert that the discardCount has not changed, otherwise print
        -:  145:		'discardCount changed but shouldn't have'. */
        -:  146:
        -:  147:	//if (backup.discardCount[currentPlayer] != G.discardCount[currentPlayer])
        1:  148:	if (backup.playedCardCount -1 != G.playedCardCount -1)
branch  0 taken 100%
branch  1 taken 0%
        -:  149:	{
        -:  150:		//printf("Error 'discardCard': should be discardCount .. but is playedCardCount array\n");
        1:  151:		printf("Error Mine: playedCardCount changed.\n\n");
        1:  152:	}
        -:  153:
        -:  154:	/* The handCount should change.
        -:  155:	   Assert if backup.handCount[currentPlayer] == G.handCount[currentPlayer]
        -:  156:	   print 'Error Mine: handCount didn't change.\n'	*/
        1:  157:	if (backup.handCount[currentPlayer] == G.handCount[currentPlayer])
branch  0 taken 0%
branch  1 taken 100%
        -:  158:	{
    #####:  159:		printf("Error Mine: handCount didn't change.\n");
    #####:  160:	}
        -:  161:
        -:  162:	/*	Assert if backup.supplyCount[choice2] > 0 and choice2 was not in
        -:  163:		previous hand, and is not in current hand, print
        -:  164:		'choice2 not found in hand after mine'. */
        1:  165:	if (backup.supplyCount[moneyToGet] > 0)
branch  0 taken 100%
branch  1 taken 0%
        -:  166:	{
        1:  167:		int found = 0;
        -:  168:		int iter;
        2:  169:		for (iter = 0; iter < G.handCount[currentPlayer]; iter++)
branch  0 taken 100%
branch  1 taken 0%
        -:  170:		{
        -:  171:			// is it in hand now ??
        1:  172:			if (G.hand[currentPlayer][iter] == moneyToGet)
branch  0 taken 100%
branch  1 taken 0%
        -:  173:			{
        1:  174:				found = 1;
        1:  175:				break;
        -:  176:			}
        -:  177:
    #####:  178:		}
        -:  179:
        1:  180:		if (found)
branch  0 taken 100%
branch  1 taken 0%
        -:  181:		{
        1:  182:			printf("Error Mine: choice2 not found in hand after the call.\n\n");
        1:  183:		}
        -:  184:
        1:  185:	}
        -:  186:
        -:  187:	/*	Compare the supplyCount[silver] before and after the call.If the
        -:  188:		current count is not 1 less than previous, then print
        -:  189:		'choice2 silver not 1 less than previous' */
        1:  190:	if (backup.supplyCount[silver] - 1 != G.supplyCount[silver])
branch  0 taken 0%
branch  1 taken 100%
        -:  191:	{
    #####:  192:		printf("Error Mine: choice2 silver is not -1 previous supplyCount.\n\n");
    #####:  193:	}
        -:  194:
        1:  195:	printf("*** END Bug1 Unit Test ***\n\n");
        1:  196:	return 0;
        -:  197:}
        -:  198:
        -:  199:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  200:/* *** FUNCTION SPECIFICATIONS ***																	*/
        -:  201:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  202:
        -:  203:/* This function adds memset initialization, and prints error if fail  */
function initTestGame called 1 returned 100% blocks executed 75%
        -:  204:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game)
        -:  205:{
        1:  206:	memset(game, '\0', sizeof(struct gameState));   // clear mem of 
        -:  207:
        1:  208:	int checkInit = initializeGame(numPlayers, kDeck, mySeed, game); // initialize 2 player game 
        -:  209:
        1:  210:	if (checkInit == -1)
branch  0 taken 0%
branch  1 taken 100%
        -:  211:	{
    #####:  212:		printf("Bad game initialization.\n");
    #####:  213:	}
        -:  214:
        1:  215:}
        -:  216:
        -:  217:// set player to remove all cards from current player's deck  
function emptyDeck called 1 returned 100% blocks executed 100%
        -:  218:void emptyDeck(int player, struct gameState* state)
        -:  219:{
        1:  220:	int i = 0;
       12:  221:	while (i < state->deckCount[player])
branch  0 taken 83%
branch  1 taken 17%
        -:  222:	{
        5:  223:		state->deck[player][i] = -1;
        5:  224:		i++;
        -:  225:	}
        1:  226:	state->deckCount[player] = 0;
        1:  227:}
        -:  228:
        -:  229:// set player to remove all cards from current player's deck   
function emptyPlayedCards called 1 returned 100% blocks executed 80%
        -:  230:void emptyPlayedCards(struct gameState* state)
        -:  231:{
        1:  232:	int i = 0;
        2:  233:	while (i < state->playedCardCount)
branch  0 taken 0%
branch  1 taken 100%
        -:  234:	{
    #####:  235:		state->playedCards[i] = -1;
    #####:  236:		i++;
        -:  237:	}
        1:  238:	state->playedCardCount = 0;
        1:  239:}
        -:  240:
        -:  241:// eliminate all cards from discard.   
function emptyDiscard called 1 returned 100% blocks executed 80%
        -:  242:void emptyDiscard(int player, struct gameState* state)
        -:  243:{
        1:  244:	int i = 0;
        2:  245:	while (i < state->discardCount[player])
branch  0 taken 0%
branch  1 taken 100%
        -:  246:	{
    #####:  247:		state->discard[player][i] = -1;
    #####:  248:		i++;
        -:  249:	}
        1:  250:	state->discardCount[player] = 0;
        1:  251:}
        -:  252:
        -:  253:/* Sets current player's handCount to newHandSize, then
        -:  254:	overwrites everything in hand with -1 */
function emptyHand called 1 returned 100% blocks executed 100%
        -:  255:void emptyHand(int player, struct gameState* state)
        -:  256:{
        -:  257:	int i;
       12:  258:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17%
        -:  259:	{
        5:  260:		state->hand[player][i] = -1;
        5:  261:	}
        1:  262:	state->handCount[player] = 0;
        1:  263:}
        -:  264:
        -:  265:// sets handCount of player to newHandSize
function setNewHandCount called 1 returned 100% blocks executed 100%
        -:  266:void setNewHandCount(int player, struct gameState* state, int newHandSize)
        -:  267:{
        1:  268:	state->handCount[player] = newHandSize;
        1:  269:}
        -:  270:
        -:  271:// adds indicated card in current player's hand at handPos 
function setAtHandPos called 2 returned 100% blocks executed 100%
        -:  272:void setAtHandPos(int player, struct gameState* state, int card, int handPos)
        -:  273:{
        2:  274:	state->hand[player][handPos] = card;
        2:  275:}
        -:    0:Source:bug1b_unittest.c
        -:    0:Graph:bug1b_unittest.gcno
        -:    0:Data:bug1b_unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*************************************************
        -:    2:* FileName: bug1b_unittest.c
        -:    3:* Author:	Glen Gougeon
        -:    4:* Class:	CS362 Software Engineering II
        -:    5:* Created:	11-29-2019
        -:    6:* Last Mod:	11-29-2019
        -:    7:*
        -:    8:* Assignement: Final Project Part B/
        -:    9:*
        -:   10:* Description:	Unit Test for Bug 1b:
        -:   11:*				Remodel Trash failure
        -:   12:*
        -:   13:**************************************************/
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "interface.h"
        -:   22:#include "rngs.h"
        -:   23:
        -:   24:// TEST PROTO-TYPES
        -:   25:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game);
        -:   26:
        -:   27:// HELPER PROTOS-TYPES
        -:   28:void emptyDeck(int player, struct gameState* state);
        -:   29:void emptyDiscard(int player, struct gameState* state);
        -:   30:
        -:   31:// HAND RELATED PROTO-TYPES
        -:   32:void emptyHand(int player, struct gameState* dState);
        -:   33:void setNewHandCount(int player, struct gameState* state, int newHandSize);
        -:   34:void setAtHandPos(int player, struct gameState* state, int card, int handPos);
        -:   35:
function main called 1 returned 100% blocks executed 72%
        -:   36:int main()
        -:   37:{
        1:   38:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        1:   39:	printf("*** START Bug1-B Unit Test: Remodel Trash Failure ***\n");
        1:   40:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        1:   41:	printf("Note* discardCard() broken. Where would test contents of discard..\n");
        1:   42:	printf("      I am testing against contents of playedCards instead.\n\n");
        -:   43:
        -:   44:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   45:	/* ** SETUP TEST SECTION ** */
        -:   46:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   47:
        1:   48:	int kingdomCards[10] = { adventurer, ambassador, baron, estate, tribute, minion, mine,  gardens, remodel, smithy };
        -:   49:
        -:   50:	struct gameState G;
        -:   51:	struct gameState backup;
        -:   52:
        1:   53:	int seed = 1;
        1:   54:	int numPlayers = 2;
        1:   55:	int currentPlayer = 0;
        1:   56:	int newHandSize = 2;
        1:   57:	int remodel_index = 0; // handPos remodel
        1:   58:	int idxOfChoice1 = 1; // choice1 remodel
        1:   59:	int cardToGet = estate; // choice2 remodel
        1:   60:	int blank = -1;
        1:   61:	int coinBonus = 0;
        -:   62:
        -:   63:	// initialize and set currentPlayer
        1:   64:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   65:	currentPlayer = G.whoseTurn;
        -:   66:
        -:   67:	// empty every deck currentPlayer has
        1:   68:	emptyDeck(currentPlayer, &G);
        1:   69:	emptyDiscard(currentPlayer, &G);
        1:   70:	emptyHand(currentPlayer, &G);
        -:   71:
        -:   72:	// you will only have a copper in your hand
        1:   73:	setNewHandCount(currentPlayer, &G, newHandSize);
        -:   74:
        -:   75:	// place remodel card in hand
        1:   76:	setAtHandPos(currentPlayer, &G, remodel, remodel_index);
        -:   77:
        -:   78:	// The only copper in the game is in currentPlayer's hand
        1:   79:	G.supplyCount[copper] = 0;
        -:   80:
        -:   81:	// The only silver in the game is THIS in supply
        1:   82:	G.supplyCount[estate] = 0;
        1:   83:	G.supplyCount[estate] = 1;
        -:   84:
        1:   85:	setAtHandPos(currentPlayer, &G, copper, idxOfChoice1);
        1:   86:	updateCoins(currentPlayer, &G, coinBonus);
        -:   87:
        -:   88:	/* BACK UP STATE BEFORE CALL */
        1:   89:	memset(&backup, '\0', sizeof(backup));
        1:   90:	backup = G;
        -:   91:
        -:   92:	/* CALL TO REMODEL <-----------------------------------------------------*/
        1:   93:	cardEffect(remodel, idxOfChoice1, cardToGet, blank, &G, remodel_index, &coinBonus);
        -:   94:
        -:   95:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   96:	/* ** ASSERTS SECTION ** */
        -:   97:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   98:	
        -:   99:	/* a) Assert that choice1(an index) is a different card, otherwise print that it
        -:  100:	   is the same. */
        1:  101:	if (backup.hand[currentPlayer][idxOfChoice1] == backup.hand[currentPlayer][idxOfChoice1])
branch  0 taken 100%
branch  1 taken 0%
        -:  102:	{
        1:  103:		printf("Error Remodel: choice1 is still the same but shouldn't be.\n\n");
        1:  104:	}
        -:  105:
        -:  106:	/* b) Assert if top of previous discard was not the same as choice1, and
        -:  107:	   choice1 is found at the top of discard, print 'choice1 discarded
        -:  108:	   not trashed'. */
        -:  109:
        -:  110:	/* b) IF DISCARD WAS REFACTORED - VERSION COMMENTED OUT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:  111:	if (backup.discard[currentPlayer][backup.discardCount[currentPlayer] -1] != copper)
        -:  112:	{
        -:  113:		if (G.discard[currentPlayer][G.discardCount[currentPlayer] - 1] == copper)
        -:  114:		{
        -:  115:			printf("Error Remodel: choice1 found at top of discard, but should be at top of trashPile.\n\n");
        -:  116:		}
        -:  117:	}
        -:  118:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        -:  119:
        1:  120:	if (backup.playedCards[backup.playedCardCount - 1] != copper)
branch  0 taken 100%
branch  1 taken 0%
        -:  121:	{
        1:  122:		if (G.playedCards[G.playedCardCount - 1] == copper)
branch  0 taken 100%
branch  1 taken 0%
        -:  123:		{
        -:  124:			//printf("Error 'discardCard': should be discard .. but is playedCards array\n");
        1:  125:			printf("Error Remodel: choice1 found in playedCards, but should be at top of trashPile.\n\n");
        1:  126:		}
        1:  127:	}
        -:  128:
        -:  129:	/* Assert if top of previous discard was the same as choice1, and the
        -:  130:	   top 2 cards in discard are both choice1, print 'choice1 discarded
        -:  131:	   not trashed'. */
        -:  132:
        -:  133:	/* IF DISCARD CARD WAS REFACTORED - VERSION COMMENTED OUT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:  134:	if (backup.discard[currentPlayer][backup.discardCount[currentPlayer] -1] == copper)
        -:  135:	{
        -:  136:		if ((G.discard[currentPlayer][G.discardCount[currentPlayer] - 1] == copper) &&
        -:  137:			(G.discard[currentPlayer][G.discardCount[currentPlayer] - 2] == copper))
        -:  138:		{
        -:  139:			printf("Error Remodel: choice1 discarded not trashed.\n\n");
        -:  140:		}
        -:  141:	}
        -:  142:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        -:  143:
        1:  144:	if (backup.playedCards[backup.playedCardCount - 1] == copper)
branch  0 taken 0%
branch  1 taken 100%
        -:  145:	{
    #####:  146:		if ((G.playedCards[G.playedCardCount - 1] == copper) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  147:			(G.playedCards[G.playedCardCount - 2] == copper))
        -:  148:		{
        -:  149:			//printf("Error 'discardCard': should be discard .. but is playedCards array\n");
    #####:  150:			printf("Error Remodel: choice1 found in playedCards NOT in trash.\n\n");
    #####:  151:		}
    #####:  152:	}
        -:  153:
        -:  154:	/* Assert if backup.supplyCount[choice2] > 0 and choice2 was not in
        -:  155:   previous top of discard, and is not in current top of discard, print
        -:  156:   'choice2 not found in top of discard after remodel'. */
        -:  157:
        -:  158:	/* IF DISCARD CARD WAS REFACTORED - VERSION COMMENTED OUT ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:  159:	if (backup.supplyCount[cardToGet] > 0)
        -:  160:	{
        -:  161:		if ((backup.discard[currentPlayer][backup.discardCount[currentPlayer] - 1] != cardToGet) &&
        -:  162:			(G.discard[currentPlayer][G.discardCount[currentPlayer] - 1] != cardToGet))
        -:  163:		{
        -:  164:			printf("Error Remodel. choice2 card to gain not found in top of discard after remodel.\n\n");
        -:  165:		}
        -:  166:	}
        -:  167:	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        -:  168:
        1:  169:	if (backup.supplyCount[cardToGet] > 0)
branch  0 taken 100%
branch  1 taken 0%
        -:  170:	{
        2:  171:		if ((backup.playedCards[backup.playedCardCount - 1] != cardToGet) &&
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        1:  172:			(G.playedCards[G.playedCardCount - 1] != cardToGet))
        -:  173:		{
        1:  174:			printf("Error Remodel. choice2 card to gain not found in top of discard after remodel.\n");
        1:  175:			printf("               *actually not in playedCards .. b/c that is where 'discardCard' places cards.\n\n");
        1:  176:		}
        1:  177:	}
        -:  178:
        -:  179:	/* The handCount should change.
        -:  180:   Assert if backup.handCount[currentPlayer] == G.handCount[currentPlayer]
        -:  181:   print 'Error Remodel: handCount didn't change.\n'	*/
        1:  182:	if (backup.handCount[currentPlayer] == G.handCount[currentPlayer])
branch  0 taken 0%
branch  1 taken 100%
        -:  183:	{
    #####:  184:		printf("Error Remodel: handCount didn't change.\n");
    #####:  185:	}
        -:  186:
        -:  187:	/* Compare the supplyCount[estate] before and after the call.If the
        -:  188:	   current count is not 1 less than previous, then print
        -:  189:	   'choice2 estate not 1 less than previous' */
        1:  190:	if (backup.supplyCount[estate] - 1 != G.supplyCount[estate])
branch  0 taken 0%
branch  1 taken 100%
        -:  191:	{
    #####:  192:		printf("Error Remodel: choice2 estate is not -1 previous supplyCount.\n\n");
    #####:  193:	}
        -:  194:
        1:  195:	printf("*** END Bug1-B Unit Test ***\n\n");
        1:  196:	return 0;
        -:  197:}
        -:  198:
        -:  199:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  200:/* *** FUNCTION SPECIFICATIONS ***																	*/
        -:  201:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  202:
        -:  203:/* This function adds memset initialization, and prints error if fail  */
function initTestGame called 1 returned 100% blocks executed 75%
        -:  204:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game)
        -:  205:{
        1:  206:	memset(game, '\0', sizeof(struct gameState));   // clear mem of 
        -:  207:
        1:  208:	int checkInit = initializeGame(numPlayers, kDeck, mySeed, game); // initialize 2 player game 
        -:  209:
        1:  210:	if (checkInit == -1)
branch  0 taken 0%
branch  1 taken 100%
        -:  211:	{
    #####:  212:		printf("Bad game initialization.\n");
    #####:  213:	}
        -:  214:
        1:  215:}
        -:  216:
        -:  217:// set player to remove all estates from current player's deck  
function emptyDeck called 1 returned 100% blocks executed 100%
        -:  218:void emptyDeck(int player, struct gameState* state)
        -:  219:{
        1:  220:	int i = 0;
       12:  221:	while (i < state->deckCount[player])
branch  0 taken 83%
branch  1 taken 17%
        -:  222:	{
        5:  223:		state->deck[player][i] = -1;
        5:  224:		i++;
        -:  225:	}
        1:  226:	state->deckCount[player] = 0;
        1:  227:}
        -:  228:
        -:  229:// eliminate all estates from discard.   
function emptyDiscard called 1 returned 100% blocks executed 80%
        -:  230:void emptyDiscard(int player, struct gameState* state)
        -:  231:{
        1:  232:	int i = 0;
        2:  233:	while (i < state->discardCount[player])
branch  0 taken 0%
branch  1 taken 100%
        -:  234:	{
    #####:  235:		state->discard[player][i] = -1;
    #####:  236:		i++;
        -:  237:	}
        1:  238:	state->discardCount[player] = 0;
        1:  239:}
        -:  240:
        -:  241:/* Sets current player's handCount to newHandSize, then
        -:  242:	overwrites everything in hand with -1 */
function emptyHand called 1 returned 100% blocks executed 100%
        -:  243:void emptyHand(int player, struct gameState* state)
        -:  244:{
        -:  245:	int i;
       12:  246:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17%
        -:  247:	{
        5:  248:		state->hand[player][i] = -1;
        5:  249:	}
        1:  250:	state->handCount[player] = 0;
        1:  251:}
        -:  252:
        -:  253:// sets handCount of player to newHandSize
function setNewHandCount called 1 returned 100% blocks executed 100%
        -:  254:void setNewHandCount(int player, struct gameState* state, int newHandSize)
        -:  255:{
        1:  256:	state->handCount[player] = newHandSize;
        1:  257:}
        -:  258:
        -:  259:// adds indicated card in current player's hand at handPos 
function setAtHandPos called 2 returned 100% blocks executed 100%
        -:  260:void setAtHandPos(int player, struct gameState* state, int card, int handPos)
        -:  261:{
        2:  262:	state->hand[player][handPos] = card;
        2:  263:}
        -:    0:Source:bug2unittest.c
        -:    0:Graph:bug2unittest.gcno
        -:    0:Data:bug2unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include "rngs.h"
        -:    7:
function assertMineCard called 1 returned 100% blocks executed 80%
        -:    8:void assertMineCard(int card, int choice1, int choice2, int choice3, struct gameState *G, int handPos, int *bonus) {
        -:    9:    
        -:   10:    // Assertion
        1:   11:    if (cardEffect(card, choice1, choice2, choice3, G, handPos, bonus) == 0) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   12:        printf("Choice of card to gain determined as valid. No errors.\n\n");
    #####:   13:    }
        -:   14:    else {
        1:   15:        printf("Choice of card to gain determined as invalid. Error encountered.\n\n");
        -:   16:    }
        1:   17:}
        -:   18: 
function main called 1 returned 100% blocks executed 100%
        -:   19:int main () {
        1:   20:    int numPlayers = 2;
        1:   21:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   22:           , remodel, smithy, village, baron, great_hall};   
        1:   23:    int seed = 10; 
        -:   24:    struct gameState G;
        -:   25:    int initResult;
        1:   26:    int handCount = 2;
        1:   27:    int cards[handCount];
        1:   28:    int currentPlayer = 0;
        -:   29:
        -:   30:    // Argument variables for cardEffect()
        -:   31:    int card;
        -:   32:    int choice1;
        -:   33:    int choice2;
        -:   34:    int choice3;
        -:   35:    int handPos;
        -:   36:    int *bonus;
        -:   37:
        1:   38:    printf("\n\nBegin Testing Mine cardEffect:\n");
        -:   39:
        1:   40:    memset(&G, 23, sizeof(struct gameState)); 
        -:   41:
        1:   42:    initResult = initializeGame(numPlayers, k, seed, &G);
        -:   43:
        -:   44:    // Proceed if game initialization successful
        1:   45:    if (initResult == 0) {    
branch  0 taken 100%
branch  1 taken 0%
        -:   46:
        -:   47:        // Set hand and hand count for all players
        6:   48:        for (int i = 0; i < numPlayers; i++) {
branch  0 taken 67%
branch  1 taken 33%
        2:   49:            G.handCount[i] = handCount;
        2:   50:            memcpy(G.hand[i], cards, sizeof(int) * handCount);  
        2:   51:        }
        -:   52:
        -:   53:        // Manually set the cards in the first player's hand
        1:   54:        G.hand[currentPlayer][0] = mine;
        1:   55:        G.hand[currentPlayer][1] = gold;
        -:   56:
        -:   57:        // Set turn to first player
        1:   58:        G.whoseTurn = currentPlayer;
        -:   59:
        -:   60:        // Set arguments so that current player will choose 
        -:   61:        // to trash a gold card to gain a copper card
        1:   62:        card = mine;
        1:   63:        choice1 = 1;        // Index of gold card
        1:   64:        choice2 = copper;   // Copper card selected to be gained
        1:   65:        choice3 = 0;        // Unused
        1:   66:        handPos = 0;        // Unused
        1:   67:        bonus = NULL;      // Unused
        -:   68:
        1:   69:        assertMineCard(card, choice1, choice2, choice3, &G, handPos, bonus);
        1:   70:    }          
        -:   71:                                        
        1:   72:    return 0;
        1:   73:}
        -:    0:Source:bug3unittest.c
        -:    0:Graph:bug3unittest.gcno
        -:    0:Data:bug3unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include "rngs.h"
        -:    7:
function assertRemodelCard called 1 returned 100% blocks executed 80%
        -:    8:void assertRemodelCard(int card, int choice1, int choice2, int choice3, struct gameState *G, int handPos, int *bonus) {
        -:    9:    
        -:   10:    // Assertion
        1:   11:    if (cardEffect(card, choice1, choice2, choice3, G, handPos, bonus) == 0) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   12:        printf("Choice of card to gain determined as valid. No errors.\n\n");
    #####:   13:    }
        -:   14:    else {
        1:   15:        printf("Choice of card to gain determined as invalid. Error encountered.\n\n");
        -:   16:    }
        1:   17:}
        -:   18: 
function main called 1 returned 100% blocks executed 100%
        -:   19:int main () {
        1:   20:    int numPlayers = 2;
        1:   21:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   22:           , remodel, smithy, village, baron, great_hall};   
        1:   23:    int seed = 10; 
        -:   24:    struct gameState G;
        -:   25:    int initResult;
        1:   26:    int handCount = 2;
        1:   27:    int cards[handCount];
        1:   28:    int currentPlayer = 0;
        -:   29:
        -:   30:    // Argument variables for cardEffect()
        -:   31:    int card;
        -:   32:    int choice1;
        -:   33:    int choice2;
        -:   34:    int choice3;
        -:   35:    int handPos;
        -:   36:    int *bonus;
        -:   37:
        1:   38:    printf("\n\nBegin Testing Remodel cardEffect:\n");
        -:   39:
        1:   40:    memset(&G, 23, sizeof(struct gameState)); 
        -:   41:
        1:   42:    initResult = initializeGame(numPlayers, k, seed, &G);
        -:   43:
        -:   44:    // Proceed if game initialization successful
        1:   45:    if (initResult == 0) {    
branch  0 taken 100%
branch  1 taken 0%
        -:   46:
        -:   47:        // Set hand and hand count for all players
        6:   48:        for (int i = 0; i < numPlayers; i++) {
branch  0 taken 67%
branch  1 taken 33%
        2:   49:            G.handCount[i] = handCount;
        2:   50:            memcpy(G.hand[i], cards, sizeof(int) * handCount);  
        2:   51:        }
        -:   52:
        -:   53:        // Manually set the cards in the first player's hand
        1:   54:        G.hand[currentPlayer][0] = remodel;
        1:   55:        G.hand[currentPlayer][1] = gold;
        -:   56:
        -:   57:        // Set turn to first player
        1:   58:        G.whoseTurn = currentPlayer;
        -:   59:
        -:   60:        // Set arguments so that current player will choose 
        -:   61:        // to trash a gold card to gain a copper card
        1:   62:        card = remodel;
        1:   63:        choice1 = 1;        // Index of gold card
        1:   64:        choice2 = copper;   // Copper card selected to be gained
        1:   65:        choice3 = 0;        // Unused
        1:   66:        handPos = 0;        // Unused
        1:   67:        bonus = NULL;       // Unused
        -:   68:
        1:   69:        assertRemodelCard(card, choice1, choice2, choice3, &G, handPos, bonus);
        1:   70:    }          
        -:   71:                                        
        1:   72:    return 0;
        1:   73:}
        -:    0:Source:bug4unittest.c
        -:    0:Graph:bug4unittest.gcno
        -:    0:Data:bug4unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include <string.h>
        -:    4:#include <stdio.h>
        -:    5:#include <assert.h>
        -:    6:#include "rngs.h"
        -:    7:
function assertGameOver called 1 returned 100% blocks executed 80%
        -:    8:void assertGameOver(struct gameState *G) {
        -:    9:    
        -:   10:    // Assertion
        1:   11:    if (isGameOver(G) == 1) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   12:        printf("Game over status is correctly detected for 3 empty piles. No errors.\n\n");
    #####:   13:    }
        -:   14:    else {
        1:   15:        printf("Game over status is incorrectly detected for 3 empty piles. Error detected.\n\n");
        -:   16:    }  
        1:   17:}
        -:   18: 
function main called 1 returned 100% blocks executed 100%
        -:   19:int main () {
        1:   20:    int numPlayers = 2;
        1:   21:    int k[10] = {adventurer, council_room, feast, gardens, mine
        -:   22:           , remodel, smithy, village, baron, great_hall};   
        1:   23:    int seed = 10; 
        -:   24:    struct gameState G;
        -:   25:    int initResult;
        -:   26:
        1:   27:    printf("\n\nBegin Testing isGameOver():\n");
        -:   28:
        1:   29:    memset(&G, 23, sizeof(struct gameState)); 
        -:   30:
        1:   31:    initResult = initializeGame(numPlayers, k, seed, &G);
        -:   32:
        -:   33:    // Proceed if game initialization successful
        1:   34:    if (initResult == 0) {    
branch  0 taken 100%
branch  1 taken 0%
        -:   35:        // Set supply counts
       50:   36:        for (int i = 0; i < 24; i++) {
branch  0 taken 96%
branch  1 taken 4%
       24:   37:            G.supplyCount[i] = i + 1;
       24:   38:        }
        -:   39:
        -:   40:        // Manually set supply count for last 3 cards
        1:   41:        G.supplyCount[24] = 0;
        1:   42:        G.supplyCount[25] = 0;
        1:   43:        G.supplyCount[26] = 0;
        -:   44:        
        1:   45:        assertGameOver(&G);
        1:   46:    }          
        -:   47:                                        
        1:   48:    return 0;
        -:   49:}
        -:    0:Source:bug5unittest.c
        -:    0:Graph:bug5unittest.gcno
        -:    0:Data:bug5unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:#include "dominion.h"
        -:    3:#include "dominion_helpers.h"
        -:    4:#include "rngs.h"
        -:    5:#include <stdio.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:
        -:    9:
        -:   10:
function assertScoreFor called 1 returned 100% blocks executed 80%
        -:   11:void assertScoreFor (int testScore, int calcScore) {
        -:   12:
        -:   13:    // Assertion
        1:   14:    if (testScore == calcScore) {
branch  0 taken 100%
branch  1 taken 0%
        1:   15:        printf("Score is correctly calculated for current player. No errors.\n\n");
        1:   16:    }
        -:   17:    else {
    #####:   18:        printf("Score is incorrectly calculated for current player. Error detected.\n\n");
        -:   19:    }
        1:   20:}
        -:   21:
        -:   22:
        -:   23:
function calculateScore called 1 returned 100% blocks executed 52%
        -:   24:int calculateScore (int player, struct gameState *state) {
        -:   25:
        -:   26:    int i;
        1:   27:    int score = 0;
        -:   28:    //score from hand
       12:   29:    for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17%
        -:   30:    {
        5:   31:        if (state->hand[player][i] == curse) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   32:            score = score - 1;
    #####:   33:        };
        5:   34:        if (state->hand[player][i] == estate) {
branch  0 taken 20%
branch  1 taken 80%
        1:   35:            score = score + 1;
        1:   36:        };
        5:   37:        if (state->hand[player][i] == duchy) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   38:            score = score + 3;
    #####:   39:        };
        5:   40:        if (state->hand[player][i] == province) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   41:            score = score + 6;
    #####:   42:        };
        5:   43:        if (state->hand[player][i] == great_hall) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   44:            score = score + 1;
    #####:   45:        };
        5:   46:        if (state->hand[player][i] == gardens) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   47:            score = score + ( fullDeckCount(player, 0, state) / 10 );
    #####:   48:        };
        5:   49:    }
        -:   50:
        -:   51:    //score from discard
        2:   52:    for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 0%
branch  1 taken 100%
        -:   53:    {
    #####:   54:        if (state->discard[player][i] == curse) {
branch  0 never executed
branch  1 never executed
    #####:   55:            score = score - 1;
    #####:   56:        };
    #####:   57:        if (state->discard[player][i] == estate) {
branch  0 never executed
branch  1 never executed
    #####:   58:            score = score + 1;
    #####:   59:        };
    #####:   60:        if (state->discard[player][i] == duchy) {
branch  0 never executed
branch  1 never executed
    #####:   61:            score = score + 3;
    #####:   62:        };
    #####:   63:        if (state->discard[player][i] == province) {
branch  0 never executed
branch  1 never executed
    #####:   64:            score = score + 6;
    #####:   65:        };
    #####:   66:        if (state->discard[player][i] == great_hall) {
branch  0 never executed
branch  1 never executed
    #####:   67:            score = score + 1;
    #####:   68:        };
    #####:   69:        if (state->discard[player][i] == gardens) {
branch  0 never executed
branch  1 never executed
    #####:   70:            score = score + ( fullDeckCount(player, 0, state) / 10 );
    #####:   71:        };
    #####:   72:    }
        -:   73:
        -:   74:    //score from deck
       12:   75:    for (i = 0; i < state->deckCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17%
        -:   76:    {
        5:   77:        if (state->deck[player][i] == curse) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   78:            score = score - 1;
    #####:   79:        };
        5:   80:        if (state->deck[player][i] == estate) {
branch  0 taken 40%
branch  1 taken 60%
        2:   81:            score = score + 1;
        2:   82:        };
        5:   83:        if (state->deck[player][i] == duchy) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   84:            score = score + 3;
    #####:   85:        };
        5:   86:        if (state->deck[player][i] == province) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   87:            score = score + 6;
    #####:   88:        };
        5:   89:        if (state->deck[player][i] == great_hall) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   90:            score = score + 1;
    #####:   91:        };
        5:   92:        if (state->deck[player][i] == gardens) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   93:            score = score + ( fullDeckCount(player, 0, state) / 10 );
    #####:   94:        };
        5:   95:    }
        -:   96:
        1:   97:    return score;
        -:   98:}
        -:   99:
        -:  100:
        -:  101:
function main called 1 returned 100% blocks executed 100%
        -:  102:int main () {
        -:  103:
        1:  104:printf("/****************************************\n");
        1:  105:printf("/***********   BUG 5 TEST   *************\n");
        1:  106:printf("/****************************************\n");
        -:  107:
        1:  108:int currentPlayer = 0;
        -:  109:
        -:  110:struct gameState G;
        -:  111:
        1:  112:int * k = kingdomCards(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        -:  113:
        1:  114:initializeGame (2, k, 8, &G);
        -:  115:
        1:  116:int testScore = calculateScore(currentPlayer, &G);
        -:  117:
        1:  118:int calcScore = scoreFor (currentPlayer, &G);
        -:  119:
        1:  120:assertScoreFor(testScore, calcScore);
        -:  121:
        1:  122:printf("\n");
        1:  123:printf("\n");
        1:  124:printf("\n");
        -:  125:
        1:  126:return 0;
        -:  127:};
        -:    0:Source:bug6unittest.c
        -:    0:Graph:bug6unittest.gcno
        -:    0:Data:bug6unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:#include "dominion.h"
        -:    3:#include "dominion_helpers.h"
        -:    4:#include "rngs.h"
        -:    5:#include <stdio.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:
        -:    9:
        -:   10:/*
        -:   11:void assertLess (int coinStorage, int currentCoin) {
        -:   12:
        -:   13:    // Assertion
        -:   14:    if (currentCoin == coinStorage) {
        -:   15:        printf("Coins are correctly calculated for current player when buying card worth less than 5. No errors.\n\n");
        -:   16:    }
        -:   17:    else if (currentCoin > coinStorage) {
        -:   18:        printf("Coins are incorrectly calculated for current player when buying card worth less than 5. Error detected -- player has too many coins.\n\n");
        -:   19:    }
        -:   20:
        -:   21:    else {
        -:   22:        printf("Coins are incorrectly calculated for current player when buying card worth less than 5. Error detected -- player had too few coins.\n\n");
        -:   23:    }
        -:   24:}
        -:   25:
        -:   26:
        -:   27:void assertMore (int costs, int newCost) {
        -:   28:
        -:   29:    // Assertion
        -:   30:    if (costs == newCost) {
        -:   31:        printf("Purchase over 5 coins blocked. No errors.\n");
        -:   32:    }
        -:   33:
        -:   34:    else if (newCost <= (costs+5)) {
        -:   35:      printf("Purchase was acceptable (less than 5 coins). No errors.\n");
        -:   36:    }
        -:   37:
        -:   38:    else {
        -:   39:        printf("Player was able to buy card worth more than 5. Error detected.\n");
        -:   40:    }
        -:   41:}
        -:   42:*/
        -:   43:
        -:   44:
function main called 1 returned 100% blocks executed 100%
        -:   45:int main () {
        -:   46:
        1:   47:printf("/****************************************\n");
        1:   48:printf("/***********   BUG 6 TEST   *************\n");
        1:   49:printf("/****************************************\n");
        -:   50:
        1:   51:printf("\n");
        1:   52:printf("I actually spent a lot of time debugging this section before concluding that there is, in fact, no bug.\n");
        1:   53:printf("The full write-up can be found in Part A, but a synopsis is below:\n");
        -:   54:
        1:   55:printf("\n");
        -:   56:
        1:   57:printf("The bug thread states that the updateCoins function is causing a bug by simply giving the player 5 coins.\n");
        1:   58:printf("The argument is that this allows the player to spend more than 5 coins or keep the extras that are unspent.\n");
        1:   59:printf("However, this is based on a misunderstanding of updateCoins(). This function doesn't simply give coins.\n");
        1:   60:printf("Rather, it resets the coin count, and then gives fresh coins according to the player's hand and any passed-in bonus.\n");
        1:   61:printf("In Feast, the hand is set to -1, and then 5 is passed into the updateCoins as a bonus, effectively resetting the coin count to 5, regardless of a player's treasure cards or existing coins.\n");
        1:   62:printf("Then, the hand is restored, and updateCoins is called again with a bonus of 0, clearing any leftover coins from Feast.\n");
        1:   63:printf("Together, these negate both of the bugs listed in the bug thread. There is no bug with updateCoins in Feast.\n");
        -:   64:
        -:   65:
        -:   66:/*
        -:   67:int currentPlayer = 0;
        -:   68:
        -:   69:struct gameState G;
        -:   70:
        -:   71:int * k = kingdomCards(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        -:   72:
        -:   73:initializeGame (2, k, 8, &G);
        -:   74:
        -:   75:G.whoseTurn = currentPlayer;
        -:   76:
        -:   77://feast == 9;
        -:   78:
        -:   79:
        -:   80:G.supplyCount[15] = 3;
        -:   81:G.supplyCount[7] = 3;
        -:   82:G.supplyCount[6] = 3;
        -:   83:
        -:   84:G.hand[currentPlayer][0] = feast;
        -:   85:G.hand[currentPlayer][1] = feast;
        -:   86:G.hand[currentPlayer][2] = gold;
        -:   87:
        -:   88:updateCoins(currentPlayer, &G, 0);
        -:   89:
        -:   90:int coinStorage = G.coins;
        -:   91:
        -:   92:
        -:   93:printf("\n");
        -:   94:printf("Testing buying card worth less than 5....\n");
        -:   95://int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:   96:playCard(0, 15, 0, 0, &G);
        -:   97://cardEffect(9, 15, 0, 0, &G, 0, 0);
        -:   98:
        -:   99:int currentCoin = G.coins;
        -:  100:
        -:  101:assertLess(coinStorage, currentCoin);
        -:  102:
        -:  103:
        -:  104:G.whoseTurn = currentPlayer;
        -:  105:G.phase = 0;
        -:  106:G.numActions = 1;
        -:  107:
        -:  108:int choice1 = 7;
        -:  109:G.hand[currentPlayer][0] = feast;
        -:  110:G.hand[currentPlayer][1] = feast;
        -:  111:G.hand[currentPlayer][2] = gold;
        -:  112://G.handCount[currentPlayer] = 3;
        -:  113:
        -:  114:printf("\n");
        -:  115:printf("Testing buying card worth more than 5....\n");
        -:  116:
        -:  117:int costs = 0;
        -:  118://cardEffect(9, choice1, 0, 0, &G, 1, 0);
        -:  119:for (int e = 0; e < G.handCount[currentPlayer]; e++) {
        -:  120:  costs = costs + getCost(G.hand[currentPlayer][e]);
        -:  121:  //printf("adding Card: %d, Cost: %d\n", G.hand[currentPlayer][e], getCost(G.hand[currentPlayer][e]));
        -:  122:}
        -:  123:
        -:  124:playCard(0, choice1, 0, 0, &G);
        -:  125:
        -:  126:
        -:  127:int newCost = 0;
        -:  128://cardEffect(9, choice1, 0, 0, &G, 1, 0);
        -:  129:for (int e = 0; e < G.handCount[currentPlayer]; e++) {
        -:  130:  newCost = newCost + getCost(G.hand[currentPlayer][e]);
        -:  131:  //printf("adding Card: %d, Cost: %d\n", G.hand[currentPlayer][e], getCost(G.hand[currentPlayer][e]));
        -:  132:
        -:  133:}
        -:  134:
        -:  135://printf("cost, %d, new cost %d\n", costs, newCost);
        -:  136:
        -:  137:
        -:  138:assertMore(costs, newCost);
        -:  139:*/
        -:  140:
        1:  141:printf("\n");
        1:  142:printf("\n");
        1:  143:printf("\n");
        -:  144:
        1:  145:return 0;
        -:  146:}
        -:    0:Source:bug7unittest.c
        -:    0:Graph:bug7unittest.gcno
        -:    0:Data:bug7unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*************************************************
        -:    2:* FileName: bug7unittest.c
        -:    3:* Author:	Glen Gougeon
        -:    4:* Class:	CS362 Software Engineering II
        -:    5:* Created:	11-30-2019
        -:    6:* Last Mod:	12-1-2019
        -:    7:*
        -:    8:* Assignement: Final Project Part B/
        -:    9:*
        -:   10:* Description:	Unit Test for Bug 7:
        -:   11:*				TributeRevealedCards Buffer-OverRun
        -:   12:*
        -:   13:**************************************************/
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "interface.h"
        -:   22:#include "rngs.h"
        -:   23:
        -:   24:// TEST PROTO-TYPES
        -:   25:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game);
        -:   26:
        -:   27:// sets variable states and calls 'cardEffect' w/ 'tribute' as card
        -:   28:void subTestTribute(
        -:   29:	int testNo,
        -:   30:	char* message,
        -:   31:	struct gameState* oldState,
        -:   32:	struct gameState* newState,
        -:   33:	int newHandSize,
        -:   34:	int tribute_index,
        -:   35:	int cardInDeck
        -:   36:);
        -:   37:
        -:   38:// must be called after subTestTribute
        -:   39:void runAsserts(
        -:   40:	struct gameState* before, 
        -:   41:	struct gameState* after 
        -:   42:);
        -:   43:
        -:   44:// HELPER PROTOS-TYPES
        -:   45:void emptyDeck(int player, struct gameState* state);
        -:   46:void emptyPlayedCards(struct gameState* state);
        -:   47:void emptyDiscard(int player, struct gameState* state);
        -:   48:
        -:   49:// HAND RELATED PROTO-TYPES
        -:   50:void emptyHand(int player, struct gameState* dState);
        -:   51:void setNewHandCount(int player, struct gameState* state, int newHandSize);
        -:   52:void setAtHandPos(int player, struct gameState* state, int card, int handPos);
        -:   53:
function main called 1 returned 100% blocks executed 100%
        -:   54:int main()
        -:   55:{
        1:   56:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        1:   57:	printf("*** START Bug7 Unit Test: TributeRevealedCards Buffer-OverRun ***\n");
        1:   58:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        -:   59:
        1:   60:	int kingdomCards[10] = { adventurer, ambassador, baron, curse, estate, tribute, minion, mine, gardens, remodel };
        -:   61:
        -:   62:	struct gameState G;
        -:   63:	struct gameState backup;
        -:   64:
        1:   65:	int seed = 1;
        1:   66:	int numPlayers = 2;
        -:   67:	//int currentPlayer = 0;
        1:   68:	int newHandSize = 1;
        1:   69:	int tribute_index = 0; // handPos tribute .. not really used
        1:   70:	int cardInDeck = -1;
        1:   71:	char* test_1_message = "Place 2 treasures at top of next player's deck, then call tribute.";
        1:   72:	char* test_2_message = "Place 2 Victory cards at top of next player's deck, then call tribute.";
        1:   73:	char* test_3_message = "Place 2 Action cards at top of next player's deck, then call tribute.";
        1:   74:	char* test_4_message = "Place 2 Curses at top of next player's deck, then call tribute.";
        -:   75:
        -:   76:	// SUBTEST 1 -- 2 treasure cards
        1:   77:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   78:	cardInDeck = gold;
        1:   79:	subTestTribute(1, test_1_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:   80:	runAsserts(&backup,&G);
        1:   81:	printf("------------------------------------------------------------------------------------\n");
        -:   82:
        -:   83:	// SUBTEST 2 -- 2 victory cards
        1:   84:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   85:	cardInDeck = estate;
        1:   86:	subTestTribute(2, test_2_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:   87:	runAsserts(&backup, &G);
        1:   88:	printf("------------------------------------------------------------------------------------\n");
        -:   89:
        -:   90:	// SUBTEST 3 -- 2 action cards
        1:   91:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   92:	cardInDeck = estate;
        1:   93:	subTestTribute(3, test_3_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:   94:	runAsserts(&backup, &G);
        1:   95:	printf("------------------------------------------------------------------------------------\n");
        -:   96:
        -:   97:	// SUBTEST 4 -- 2 curse cards
        1:   98:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   99:	cardInDeck = curse;
        1:  100:	subTestTribute(4, test_4_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:  101:	runAsserts(&backup, &G);
        -:  102:
        1:  103:	return 0;
        -:  104:}
        -:  105:
        -:  106:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  107:/* *** FUNCTION SPECIFICATIONS ***																	*/
        -:  108:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  109:
        -:  110:/* This function adds memset initialization, and prints error if fail  */
function initTestGame called 4 returned 100% blocks executed 75%
        -:  111:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game)
        -:  112:{
        4:  113:	memset(game, '\0', sizeof(struct gameState));   // clear mem of 
        -:  114:
        4:  115:	int checkInit = initializeGame(numPlayers, kDeck, mySeed, game); // initialize 2 player game 
        -:  116:
        4:  117:	if (checkInit == -1)
branch  0 taken 0%
branch  1 taken 100%
        -:  118:	{
    #####:  119:		printf("Bad game initialization.\n");
    #####:  120:	}
        -:  121:
        4:  122:}
        -:  123:
        -:  124:// set player to remove all cards from current player's deck  
function emptyDeck called 8 returned 100% blocks executed 100%
        -:  125:void emptyDeck(int player, struct gameState* state)
        -:  126:{
        8:  127:	int i = 0;
      136:  128:	while (i < state->deckCount[player])
branch  0 taken 88%
branch  1 taken 12%
        -:  129:	{
       60:  130:		state->deck[player][i] = -1;
       60:  131:		i++;
        -:  132:	}
        8:  133:	state->deckCount[player] = 0;
        8:  134:}
        -:  135:
        -:  136:// set player to remove all cards from current player's deck   
function emptyPlayedCards called 8 returned 100% blocks executed 80%
        -:  137:void emptyPlayedCards(struct gameState* state)
        -:  138:{
        8:  139:	int i = 0;
       16:  140:	while (i < state->playedCardCount)
branch  0 taken 0%
branch  1 taken 100%
        -:  141:	{
    #####:  142:		state->playedCards[i] = -1;
    #####:  143:		i++;
        -:  144:	}
        8:  145:	state->playedCardCount = 0;
        8:  146:}
        -:  147:
        -:  148:// eliminate all cards from discard.   
function emptyDiscard called 8 returned 100% blocks executed 80%
        -:  149:void emptyDiscard(int player, struct gameState* state)
        -:  150:{
        8:  151:	int i = 0;
       16:  152:	while (i < state->discardCount[player])
branch  0 taken 0%
branch  1 taken 100%
        -:  153:	{
    #####:  154:		state->discard[player][i] = -1;
    #####:  155:		i++;
        -:  156:	}
        8:  157:	state->discardCount[player] = 0;
        8:  158:}
        -:  159:
        -:  160:/* Sets current player's handCount to newHandSize, then
        -:  161:	overwrites everything in hand with -1 */
function emptyHand called 8 returned 100% blocks executed 100%
        -:  162:void emptyHand(int player, struct gameState* state)
        -:  163:{
        -:  164:	int i;
       56:  165:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 71%
branch  1 taken 29%
        -:  166:	{
       20:  167:		state->hand[player][i] = -1;
       20:  168:	}
        8:  169:	state->handCount[player] = 0;
        8:  170:}
        -:  171:
        -:  172:// sets handCount of player to newHandSize
function setNewHandCount called 4 returned 100% blocks executed 100%
        -:  173:void setNewHandCount(int player, struct gameState* state, int newHandSize)
        -:  174:{
        4:  175:	state->handCount[player] = newHandSize;
        4:  176:}
        -:  177:
        -:  178:// adds indicated card in current player's hand at handPos 
function setAtHandPos called 4 returned 100% blocks executed 100%
        -:  179:void setAtHandPos(int player, struct gameState* state, int card, int handPos)
        -:  180:{
        4:  181:	state->hand[player][handPos] = card;
        4:  182:}
        -:  183:
        -:  184:// Use for running subtest on 'tribute' case of 'cardEffect' function
function subTestTribute called 4 returned 100% blocks executed 100%
        -:  185:void subTestTribute(
        -:  186:	// parameters
        -:  187:	int testNo,
        -:  188:	char* message,
        -:  189:	struct gameState* oldState, 
        -:  190:	struct gameState* newState, 
        -:  191:	int newHandSize, 
        -:  192:	int tribute_index, 
        -:  193:	int cardInDeck)
        -:  194:	// end paramaters
        -:  195:{
        4:  196:	printf(" SUB-TEST %d: %s\n\n", testNo, message);
        -:  197:
        -:  198:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  199:	/* ** SETUP TEST SECTION ** */
        -:  200:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  201:
        4:  202:	int idxOfChoice1 = 0; // choice1 tribute
        4:  203:	int blank = -1;
        4:  204:	int coinBonus = 0;
        4:  205:	int currentPlayer = newState->whoseTurn;
        4:  206:	int nextPlayer = currentPlayer + 1;
        -:  207:
        -:  208:	/* MMMMMMMMM SET UP CURRENT PLAYER *** MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
        -:  209:
        -:  210:	// empty every deck currentPlayer has
        4:  211:	emptyDeck(currentPlayer, newState);
        4:  212:	emptyPlayedCards(newState); // req'd. b/c 'discardCard' is broken !!
        4:  213:	emptyDiscard(currentPlayer, newState);
        4:  214:	emptyHand(currentPlayer, newState);
        -:  215:
        -:  216:	// set up new hand size after empty
        4:  217:	setNewHandCount(currentPlayer, newState, newHandSize);
        -:  218:
        -:  219:	// place tribute card in hand
        4:  220:	setAtHandPos(currentPlayer, newState, tribute, tribute_index);
        -:  221:
        -:  222:	// set coins appropriately
        4:  223:	updateCoins(currentPlayer, newState, coinBonus);
        -:  224:
        -:  225:	/* MMMMMMMMM SET UP NEXT PLAYER *** MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
        -:  226:
        -:  227:	// empty every deck currentPlayer has
        4:  228:	emptyDeck(nextPlayer, newState);
        4:  229:	emptyPlayedCards(newState); // req'd. b/c 'discardCard' is broken !!
        4:  230:	emptyDiscard(nextPlayer, newState);
        4:  231:	emptyHand(nextPlayer, newState);
        -:  232:
        -:  233:	// subtest 1 = ensure only 2 golds are in next player's hand
        -:  234:	// subtest 2 = ensure only 2 victory cards are in next player's hand
        -:  235:	// subtest 3 = ensure only 2 action cards are in next player's hand
        -:  236:	// subtest 4 = ensure only 2..
        -:  237:	//			   non-treasure, non-victory, non-action cards are in next player's hand
        -:  238:
        -:  239:	// empty supply of cardInDeck to ensure the ones 
        -:  240:	// going into deck are the only ones possible
        4:  241:	newState->supplyCount[cardInDeck] = 0;
        -:  242:
        -:  243:	// place 2 cards in nextPlayer's deck then increment
        4:  244:	newState->deck[nextPlayer][newState->deckCount[nextPlayer]] = cardInDeck;
        4:  245:	newState->deckCount[nextPlayer]++;
        4:  246:	newState->deck[nextPlayer][newState->deckCount[nextPlayer]] = cardInDeck;
        4:  247:	newState->deckCount[nextPlayer]++;
        -:  248:
        -:  249:	/* BACK UP STATE BEFORE CALL */
        4:  250:	memset(oldState, '\0', sizeof(*oldState));
        4:  251:	oldState = newState;
        -:  252:
        -:  253:	/* CALL TO TRIBUTE <-----------------------------------------------------*/
        4:  254:	cardEffect(tribute, idxOfChoice1, blank, blank, newState, tribute_index, &coinBonus);
        -:  255:
        4:  256:}
        -:  257:
        -:  258:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  259:/* ** ASSERTS SECTION ** */
        -:  260:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
function runAsserts called 4 returned 100% blocks executed 47%
        -:  261:void runAsserts(struct gameState* before, struct gameState* after)
        -:  262:{
        4:  263:	int currentPlayer = after->whoseTurn;
        4:  264:	int nextPlayer = currentPlayer +1;
        -:  265:
        -:  266:	char name[MAX_STRING_LENGTH];
        -:  267:	char nombre[MAX_STRING_LENGTH];
        -:  268:
        -:  269:	/*Assert that the top 2 cards from the next player's previous deck
        -:  270:	are exactly the ones found in their discard (playedCards) after the use of tribute.*/
        4:  271:	if (before->deck[nextPlayer][before->deckCount[nextPlayer] - 1] != after->discard[nextPlayer][after->discardCount[nextPlayer] - 1])
branch  0 taken 0%
branch  1 taken 100%
        -:  272:	{
    #####:  273:		if (before->deck[nextPlayer][before->deckCount[nextPlayer] - 2] != after->discard[nextPlayer][after->discardCount[nextPlayer] - 2])
branch  0 never executed
branch  1 never executed
        -:  274:		{
    #####:  275:			memset(name, '\0', sizeof name);
    #####:  276:			cardNumToName(after->discard[nextPlayer][after->discardCount[nextPlayer] - 1], name);
        -:  277:
    #####:  278:			memset(nombre, '\0', sizeof nombre);
    #####:  279:			cardNumToName(after->discard[nextPlayer][after->discardCount[nextPlayer] - 1], nombre);
        -:  280:
    #####:  281:			printf("Tribute Error: previous top 2 deck cards next player..\n");
    #####:  282:			printf("               not found in next player's discard.\n\n");
    #####:  283:			printf("               Discard top 2:\n");
    #####:  284:			printf("               G.discard[%d]: %s\n", after->discardCount[nextPlayer] - 1, name);
    #####:  285:			printf("               G.discard[%d]: %s\n\n", after->discardCount[nextPlayer] - 2, nombre);
    #####:  286:		}
    #####:  287:	}
        -:  288:
        -:  289:	/*Assert that the counts of the next player's discard and deck counts
        -:  290:	are correct, such that their deckCount is 2 less than previously, and
        -:  291:	their discardCount is 2 greater than previously.*/
        4:  292:	if (before->deckCount[nextPlayer] - 2 != after->deckCount[nextPlayer])
branch  0 taken 0%
branch  1 taken 100%
        -:  293:	{
    #####:  294:		if (before->discardCount[nextPlayer] + 2 != after->discardCount[nextPlayer])
branch  0 never executed
branch  1 never executed
        -:  295:		{
    #####:  296:			printf("Tribute Error: next player's deckCount not -2 previous.\n");
    #####:  297:			printf("             : next player's discardCount not +2 previous.\n\n");
        -:  298:
    #####:  299:		}
    #####:  300:	}
        -:  301:
        -:  302:	/*Assert if one of the top 2 cards in the next player's discard
        -:  303:	are a coin, that the current player's coin is exactly 2 greater than previously.
        -:  304:	for each treasure in discard*/
        4:  305:	int totalCoin = 0;
        8:  306:	if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == copper ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        4:  307:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == silver ||
branch  0 taken 100%
branch  1 taken 0%
        4:  308:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == gold) {
        -:  309:
        -:  310:		// 1 treasure found
    #####:  311:		totalCoin += 2;
        -:  312:
    #####:  313:		if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == copper ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  314:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == silver ||
branch  0 never executed
branch  1 never executed
    #####:  315:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == gold) {
        -:  316:
        -:  317:			// 2nd treasure found
    #####:  318:			totalCoin += 2;
    #####:  319:		}
    #####:  320:	}
        -:  321:
        4:  322:	if (totalCoin == 2)
branch  0 taken 0%
branch  1 taken 100%
        -:  323:	{
    #####:  324:		if (before->coins + 2 != after->coins)
branch  0 never executed
branch  1 never executed
        -:  325:		{
    #####:  326:			printf("Tribute Error: You had 1 treasure in discard, but didn't gain 2 coin.\n\n");
    #####:  327:		}
    #####:  328:	}
        4:  329:	else if (totalCoin == 4)
branch  0 taken 0%
branch  1 taken 100%
        -:  330:	{
    #####:  331:		if (before->coins + 4 != after->coins)
branch  0 never executed
branch  1 never executed
        -:  332:		{
    #####:  333:			printf("Tribute Error: You had 2 treasures in discard, but didn't gain 4 coin.\n\n");
    #####:  334:		}
    #####:  335:	}
        -:  336:	/*Assert that if the current player's coin went up by 2 from previous, that
        -:  337:	the next player's top 2 discarded cards are a coin, otherwise print a message*/
        8:  338:	else if (totalCoin == 0 && (before->coins != after->coins))
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 25%
branch  3 taken 75%
        -:  339:	{
        1:  340:		printf("Tribute Error: You gained coin, but didn't find a treasure in discard.\n\n");
        1:  341:	}
        -:  342:
        -:  343:	/*Assert if one of the top 2 cards in the next player's discard
        -:  344:	are a victory card, that the current player's handCount is 2 greater than previously.*/
        4:  345:	int totalVictory = 0;
        8:  346:	if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == estate ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        4:  347:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == gardens) {
        -:  348:
        -:  349:		// 1 treasure found
    #####:  350:		totalVictory += 2;
        -:  351:
    #####:  352:		if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == estate ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  353:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == gardens) {
        -:  354:
        -:  355:			// 2nd treasure found
    #####:  356:			totalVictory += 2;
    #####:  357:		}
    #####:  358:	}
        -:  359:
        4:  360:	if (totalVictory == 2)
branch  0 taken 0%
branch  1 taken 100%
        -:  361:	{
    #####:  362:		if (before->handCount[nextPlayer] + 2 != after->handCount[nextPlayer])
branch  0 never executed
branch  1 never executed
        -:  363:		{
    #####:  364:			printf("Tribute Error: You had 1 Victory card in discard, but didn't gain 2 card.\n\n");
    #####:  365:		}
    #####:  366:	}
        4:  367:	else if (totalVictory == 4)
branch  0 taken 0%
branch  1 taken 100%
        -:  368:	{
    #####:  369:		if (before->handCount[nextPlayer] + 4 != after->handCount[nextPlayer])
branch  0 never executed
branch  1 never executed
        -:  370:		{
    #####:  371:			printf("Tribute Error: You had 2 Victory card in discard, but didn't gain 4 cards.\n\n");
    #####:  372:		}
    #####:  373:	}
        -:  374:	/*Assert that if the current player's hand count went up by 2 from previous, that
        -:  375:	the next player's top 2 discarded cards are a victory card.*/
        8:  376:	else if (totalVictory == 0 && (before->handCount[nextPlayer] != after->handCount[nextPlayer]))
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:  377:	{
    #####:  378:		printf("Tribute Error: You gained cards in hand, but didn't find a Victory card in discard.\n\n");
    #####:  379:	}
        -:  380:
        -:  381:	// This will catch the error.
        -:  382:	/*Assert that if the current player's numActions went up by 2 from previous, that
        -:  383:	the next player's top 2 discarded cards are an action card, otherwise print a message*/
        -:  384:
        4:  385:	int totalActions = 0;
        8:  386:	if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == adventurer ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        4:  387:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == baron ||
branch  0 taken 100%
branch  1 taken 0%
        4:  388:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == tribute ||
branch  0 taken 100%
branch  1 taken 0%
        4:  389:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == minion ||
branch  0 taken 100%
branch  1 taken 0%
        4:  390:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == mine ||
branch  0 taken 100%
branch  1 taken 0%
        4:  391:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == remodel) {
        -:  392:
        -:  393:		// 1 action found
    #####:  394:		totalActions += 2;
        -:  395:
    #####:  396:		if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == adventurer ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  397:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == baron ||
branch  0 never executed
branch  1 never executed
    #####:  398:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == tribute ||
branch  0 never executed
branch  1 never executed
    #####:  399:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == minion ||
branch  0 never executed
branch  1 never executed
    #####:  400:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == mine ||
branch  0 never executed
branch  1 never executed
    #####:  401:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == remodel) {
        -:  402:
        -:  403:			// 2nd actions found
    #####:  404:			totalActions += 4;
    #####:  405:		}
    #####:  406:	}
        -:  407:
        4:  408:	if (totalActions == 2)
branch  0 taken 0%
branch  1 taken 100%
        -:  409:	{
    #####:  410:		if (before->numActions + 2 != after->numActions)
branch  0 never executed
branch  1 never executed
        -:  411:		{
    #####:  412:			printf("Tribute Error: You had 1 action card in discard, but didn't gain 2 actions.\n\n");
    #####:  413:		}
    #####:  414:	}
        4:  415:	else if (totalActions == 4)
branch  0 taken 0%
branch  1 taken 100%
        -:  416:	{
    #####:  417:		if (before->numActions + 4 != after->numActions)
branch  0 never executed
branch  1 never executed
        -:  418:		{
    #####:  419:			printf("Tribute Error: You had 2 action cards in discard, but didn't gain 4 actions.\n\n");
    #####:  420:		}
    #####:  421:	}
        8:  422:	else if (totalActions == 0 && (before->numActions != after->numActions))
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  423:	{
        4:  424:		printf("Tribute Error: You gained actions, but didn't find any action cards in discard.\n\n");
        4:  425:	}
        -:  426:
        -:  427:	/*Assert that if the current player's hand count went up 2 from previous, that
        -:  428:	the next player's top 2 discarded cards are a victory card.
        -:  429:		If so compare the hands to see that the contents of the current player's hand
        -:  430:		is no the same as before.Use a for loop for i in G.handCount[currentPlayer],
        -:  431:		and compare contents.Any difference should break out of loop, set a print flag,
        -:  432:		and print the error.*/
        4:  433:	if (after->handCount[currentPlayer] > before->handCount[currentPlayer])
branch  0 taken 100%
branch  1 taken 0%
        -:  434:	{
        4:  435:		if ((after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] != estate ||
branch  0 taken 0%
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  436:		     after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] != estate) &&
branch  0 never executed
branch  1 never executed
        4:  437:		    (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] != gardens ||
branch  0 taken 0%
branch  1 taken 100%
    #####:  438:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] != gardens) ){
        -:  439:
        -:  440:				// Then your handCount increased withou having a Victory card
        4:  441:				printf("Tribute Error: Your hand increased but..\n");
        4:  442:				printf("             : top 2 cards in next player's discard weren't Victory cards.\n\n");
        4:  443:			}
        4:  444:	}
        4:  445:}
        -:    0:Source:bug8unittest.c
        -:    0:Graph:bug8unittest.gcno
        -:    0:Data:bug8unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:#include "dominion.h"
        -:    3:#include "dominion_helpers.h"
        -:    4:#include "rngs.h"
        -:    5:#include <stdio.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:
        -:    9:
        -:   10:
function assertCoins called 1 returned 100% blocks executed 80%
        -:   11:void assertCoins (int coinStorage, int currentCoin) {
        -:   12:
        -:   13:    // Assertion
        1:   14:    if (currentCoin == coinStorage) {
branch  0 taken 100%
branch  1 taken 0%
        1:   15:        printf("Coins are correctly calculated for current player! No errors.\n\n");
        1:   16:    }
        -:   17:
        -:   18:    else {
    #####:   19:        printf("Coins are incorrectly calculated for current player! Error detected -- player has wrong number of coins.\n\n");
        -:   20:    }
        1:   21:}
        -:   22:
        -:   23:
        -:   24:
        -:   25:
function main called 1 returned 100% blocks executed 100%
        -:   26:int main () {
        -:   27:
        1:   28:printf("/****************************************\n");
        1:   29:printf("/***********   BUG 8 TEST   *************\n");
        1:   30:printf("/****************************************\n");
        -:   31:
        1:   32:int currentPlayer = 0;
        -:   33:
        -:   34:struct gameState G;
        -:   35:
        1:   36:int * k = kingdomCards(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        -:   37:
        1:   38:initializeGame (2, k, 8, &G);
        -:   39:
        1:   40:G.whoseTurn = currentPlayer;
        -:   41:
        -:   42://feast == 9;
        -:   43:
        1:   44:G.hand[currentPlayer][0] = baron;
        -:   45:
        1:   46:updateCoins(currentPlayer, &G, 0);
        -:   47:
        1:   48:int coinStorage = G.coins;
        -:   49:
        -:   50:
        1:   51:printf("\n");
        1:   52:printf("Testing gaining bonus coins....\n");
        -:   53://int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        1:   54:playCard(0, 0, 0, 0, &G);
        -:   55://cardEffect(9, 15, 0, 0, &G, 0, 0);
        -:   56:
        1:   57:int currentCoin = G.coins;
        -:   58:
        1:   59:assertCoins(coinStorage, currentCoin);
        -:   60:
        1:   61:printf("\n");
        1:   62:printf("\n");
        1:   63:printf("\n");
        -:   64:
        1:   65:return 0;
        -:   66:};
        -:    0:Source:bug9unittest.c
        -:    0:Graph:bug9unittest.gcno
        -:    0:Data:bug9unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*************************************************
        -:    2:* FileName: bug7unittest.c
        -:    3:* Author:	Glen Gougeon
        -:    4:* Class:	CS362 Software Engineering II
        -:    5:* Created:	11-30-2019
        -:    6:* Last Mod:	12-1-2019
        -:    7:*
        -:    8:* Assignement: Final Project Part B/
        -:    9:*
        -:   10:* Description:	Unit Test for Bug 9:
        -:   11:*				TributeRevealedCards Illegal Action Gain
        -:   12:*
        -:   13:**************************************************/
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "interface.h"
        -:   22:#include "rngs.h"
        -:   23:
        -:   24:// TEST PROTO-TYPES
        -:   25:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game);
        -:   26:
        -:   27:// sets variable states and calls 'cardEffect' w/ 'tribute' as card
        -:   28:void subTestTribute(
        -:   29:	int testNo,
        -:   30:	char* message,
        -:   31:	struct gameState* oldState,
        -:   32:	struct gameState* newState,
        -:   33:	int newHandSize,
        -:   34:	int tribute_index,
        -:   35:	int cardInDeck
        -:   36:);
        -:   37:
        -:   38:// must be called after subTestTribute
        -:   39:void runAsserts(
        -:   40:	struct gameState* before, 
        -:   41:	struct gameState* after 
        -:   42:);
        -:   43:
        -:   44:// HELPER PROTOS-TYPES
        -:   45:void emptyDeck(int player, struct gameState* state);
        -:   46:void emptyPlayedCards(struct gameState* state);
        -:   47:void emptyDiscard(int player, struct gameState* state);
        -:   48:
        -:   49:// HAND RELATED PROTO-TYPES
        -:   50:void emptyHand(int player, struct gameState* dState);
        -:   51:void setNewHandCount(int player, struct gameState* state, int newHandSize);
        -:   52:void setAtHandPos(int player, struct gameState* state, int card, int handPos);
        -:   53:
function main called 1 returned 100% blocks executed 100%
        -:   54:int main()
        -:   55:{
        1:   56:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        1:   57:	printf("*** START Bug9 Unit Test: TributeRevealedCards Illegal Action Gain ***\n");
        1:   58:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n\n");
        -:   59:
        1:   60:	int kingdomCards[10] = { adventurer, ambassador, baron, curse, estate, tribute, minion, mine, gardens, remodel };
        -:   61:
        -:   62:	struct gameState G;
        -:   63:	struct gameState backup;
        -:   64:
        1:   65:	int seed = 1;
        1:   66:	int numPlayers = 2;
        -:   67:	//int currentPlayer = 0;
        1:   68:	int newHandSize = 1;
        1:   69:	int tribute_index = 0; // handPos tribute .. not really used
        1:   70:	int cardInDeck = -1;
        1:   71:	char* test_1_message = "Place 2 treasures at top of next player's deck, then call tribute.";
        1:   72:	char* test_2_message = "Place 2 Victory cards at top of next player's deck, then call tribute.";
        1:   73:	char* test_3_message = "Place 2 non-coin & non-victory (curses) at top of next player's deck, then call tribute.";
        -:   74:
        -:   75:	// SUBTEST 1 -- 2 treasure cards
        1:   76:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   77:	cardInDeck = gold;
        1:   78:	subTestTribute(1, test_1_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:   79:	runAsserts(&backup,&G);
        1:   80:	printf("------------------------------------------------------------------------------------\n");
        -:   81:
        -:   82:	// SUBTEST 2 -- 2 victory cards
        1:   83:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   84:	cardInDeck = estate;
        1:   85:	subTestTribute(2, test_2_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:   86:	runAsserts(&backup, &G);
        1:   87:	printf("------------------------------------------------------------------------------------\n");
        -:   88:
        -:   89:	// SUBTEST 3 -- 2 non-coin, non-victory cards
        1:   90:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   91:	cardInDeck = curse;
        1:   92:	subTestTribute(3, test_3_message, &backup, &G, newHandSize, tribute_index, cardInDeck);
        1:   93:	runAsserts(&backup, &G);
        1:   94:	printf("------------------------------------------------------------------------------------\n");
        -:   95:
        1:   96:	return 0;
        -:   97:}
        -:   98:
        -:   99:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  100:/* *** FUNCTION SPECIFICATIONS ***																	*/
        -:  101:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  102:
        -:  103:/* This function adds memset initialization, and prints error if fail  */
function initTestGame called 3 returned 100% blocks executed 75%
        -:  104:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game)
        -:  105:{
        3:  106:	memset(game, '\0', sizeof(struct gameState));   // clear mem of 
        -:  107:
        3:  108:	int checkInit = initializeGame(numPlayers, kDeck, mySeed, game); // initialize 2 player game 
        -:  109:
        3:  110:	if (checkInit == -1)
branch  0 taken 0%
branch  1 taken 100%
        -:  111:	{
    #####:  112:		printf("Bad game initialization.\n");
    #####:  113:	}
        -:  114:
        3:  115:}
        -:  116:
        -:  117:// set player to remove all cards from current player's deck  
function emptyDeck called 6 returned 100% blocks executed 100%
        -:  118:void emptyDeck(int player, struct gameState* state)
        -:  119:{
        6:  120:	int i = 0;
      102:  121:	while (i < state->deckCount[player])
branch  0 taken 88%
branch  1 taken 12%
        -:  122:	{
       45:  123:		state->deck[player][i] = -1;
       45:  124:		i++;
        -:  125:	}
        6:  126:	state->deckCount[player] = 0;
        6:  127:}
        -:  128:
        -:  129:// set player to remove all cards from current player's deck   
function emptyPlayedCards called 6 returned 100% blocks executed 80%
        -:  130:void emptyPlayedCards(struct gameState* state)
        -:  131:{
        6:  132:	int i = 0;
       12:  133:	while (i < state->playedCardCount)
branch  0 taken 0%
branch  1 taken 100%
        -:  134:	{
    #####:  135:		state->playedCards[i] = -1;
    #####:  136:		i++;
        -:  137:	}
        6:  138:	state->playedCardCount = 0;
        6:  139:}
        -:  140:
        -:  141:// eliminate all cards from discard.   
function emptyDiscard called 6 returned 100% blocks executed 80%
        -:  142:void emptyDiscard(int player, struct gameState* state)
        -:  143:{
        6:  144:	int i = 0;
       12:  145:	while (i < state->discardCount[player])
branch  0 taken 0%
branch  1 taken 100%
        -:  146:	{
    #####:  147:		state->discard[player][i] = -1;
    #####:  148:		i++;
        -:  149:	}
        6:  150:	state->discardCount[player] = 0;
        6:  151:}
        -:  152:
        -:  153:/* Sets current player's handCount to newHandSize, then
        -:  154:	overwrites everything in hand with -1 */
function emptyHand called 6 returned 100% blocks executed 100%
        -:  155:void emptyHand(int player, struct gameState* state)
        -:  156:{
        -:  157:	int i;
       42:  158:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 71%
branch  1 taken 29%
        -:  159:	{
       15:  160:		state->hand[player][i] = -1;
       15:  161:	}
        6:  162:	state->handCount[player] = 0;
        6:  163:}
        -:  164:
        -:  165:// sets handCount of player to newHandSize
function setNewHandCount called 3 returned 100% blocks executed 100%
        -:  166:void setNewHandCount(int player, struct gameState* state, int newHandSize)
        -:  167:{
        3:  168:	state->handCount[player] = newHandSize;
        3:  169:}
        -:  170:
        -:  171:// adds indicated card in current player's hand at handPos 
function setAtHandPos called 3 returned 100% blocks executed 100%
        -:  172:void setAtHandPos(int player, struct gameState* state, int card, int handPos)
        -:  173:{
        3:  174:	state->hand[player][handPos] = card;
        3:  175:}
        -:  176:
        -:  177:// Use for running subtest on 'tribute' case of 'cardEffect' function
function subTestTribute called 3 returned 100% blocks executed 100%
        -:  178:void subTestTribute(
        -:  179:	// parameters
        -:  180:	int testNo,
        -:  181:	char* message,
        -:  182:	struct gameState* oldState, 
        -:  183:	struct gameState* newState, 
        -:  184:	int newHandSize, 
        -:  185:	int tribute_index, 
        -:  186:	int cardInDeck)
        -:  187:	// end paramaters
        -:  188:{
        3:  189:	printf(" SUB-TEST %d: %s\n\n", testNo, message);
        -:  190:
        -:  191:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  192:	/* ** SETUP TEST SECTION ** */
        -:  193:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  194:
        3:  195:	int idxOfChoice1 = 0; // choice1 tribute
        3:  196:	int blank = -1;
        3:  197:	int coinBonus = 0;
        3:  198:	int currentPlayer = newState->whoseTurn;
        3:  199:	int nextPlayer = currentPlayer + 1;
        -:  200:
        -:  201:	/* MMMMMMMMM SET UP CURRENT PLAYER *** MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
        -:  202:
        -:  203:	// empty every deck currentPlayer has
        3:  204:	emptyDeck(currentPlayer, newState);
        3:  205:	emptyPlayedCards(newState); // req'd. b/c 'discardCard' is broken !!
        3:  206:	emptyDiscard(currentPlayer, newState);
        3:  207:	emptyHand(currentPlayer, newState);
        -:  208:
        -:  209:	// set up new hand size after empty
        3:  210:	setNewHandCount(currentPlayer, newState, newHandSize);
        -:  211:
        -:  212:	// place tribute card in hand
        3:  213:	setAtHandPos(currentPlayer, newState, tribute, tribute_index);
        -:  214:
        -:  215:	// set coins appropriately
        3:  216:	updateCoins(currentPlayer, newState, coinBonus);
        -:  217:
        -:  218:	/* MMMMMMMMM SET UP NEXT PLAYER *** MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/
        -:  219:
        -:  220:	// empty every deck currentPlayer has
        3:  221:	emptyDeck(nextPlayer, newState);
        3:  222:	emptyPlayedCards(newState); // req'd. b/c 'discardCard' is broken !!
        3:  223:	emptyDiscard(nextPlayer, newState);
        3:  224:	emptyHand(nextPlayer, newState);
        -:  225:	
        -:  226:	// subtest 1 = ensure only 2 golds are in next player's hand
        -:  227:	// subtest 2 = ensure only 2 victory cards are in next player's hand
        -:  228:	// subtest 3 = ensure only 2 action cards are in next player's hand
        -:  229:	// subtest 4 = ensure only 2..
        -:  230:	//			   non-treasure, non-victory, non-action cards are in next player's hand
        -:  231:
        -:  232:	// empty supply of cardInDeck to ensure the ones 
        -:  233:	// going into deck are the only ones possible
        3:  234:	newState->supplyCount[cardInDeck] = 0;
        -:  235:
        -:  236:	// place 2 cards in nextPlayer's deck then increment
        3:  237:	newState->deck[nextPlayer][newState->deckCount[nextPlayer]] = cardInDeck;
        3:  238:	newState->deckCount[nextPlayer]++;
        3:  239:	newState->deck[nextPlayer][newState->deckCount[nextPlayer]] = cardInDeck;
        3:  240:	newState->deckCount[nextPlayer]++;
        -:  241:
        -:  242:	/* BACK UP STATE BEFORE CALL */
        3:  243:	memset(oldState, '\0', sizeof(*oldState));
        3:  244:	oldState = newState;
        -:  245:
        -:  246:	/* CALL TO TRIBUTE <-----------------------------------------------------*/
        3:  247:	cardEffect(tribute, idxOfChoice1, blank, blank, newState, tribute_index, &coinBonus);
        -:  248:
        3:  249:}
        -:  250:
        -:  251:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  252:/* ** ASSERTS SECTION ** */
        -:  253:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
function runAsserts called 3 returned 100% blocks executed 47%
        -:  254:void runAsserts(struct gameState* before, struct gameState* after)
        -:  255:{
        3:  256:	int currentPlayer = after->whoseTurn;
        3:  257:	int nextPlayer = currentPlayer +1;
        -:  258:
        -:  259:	char name[MAX_STRING_LENGTH];
        -:  260:	char nombre[MAX_STRING_LENGTH];
        -:  261:
        -:  262:	/*Assert that the top 2 cards from the next player's previous deck
        -:  263:	are exactly the ones found in their discard (playedCards) after the use of tribute.*/
        3:  264:	if (before->deck[nextPlayer][before->deckCount[nextPlayer] - 1] != after->discard[nextPlayer][after->discardCount[nextPlayer] - 1])
branch  0 taken 0%
branch  1 taken 100%
        -:  265:	{
    #####:  266:		if (before->deck[nextPlayer][before->deckCount[nextPlayer] - 2] != after->discard[nextPlayer][after->discardCount[nextPlayer] - 2])
branch  0 never executed
branch  1 never executed
        -:  267:		{
    #####:  268:			memset(name, '\0', sizeof name);
    #####:  269:			cardNumToName(after->discard[nextPlayer][after->discardCount[nextPlayer] - 1], name);
        -:  270:
    #####:  271:			memset(nombre, '\0', sizeof nombre);
    #####:  272:			cardNumToName(after->discard[nextPlayer][after->discardCount[nextPlayer] - 1], nombre);
        -:  273:
    #####:  274:			printf("Tribute Error: previous top 2 deck cards next player..\n");
    #####:  275:			printf("               not found in next player's discard.\n\n");
    #####:  276:			printf("               Discard top 2:\n");
    #####:  277:			printf("               G.discard[%d]: %s\n", after->discardCount[nextPlayer] - 1, name);
    #####:  278:			printf("               G.discard[%d]: %s\n\n", after->discardCount[nextPlayer] - 2, nombre);
    #####:  279:		}
    #####:  280:	}
        -:  281:
        -:  282:	/*Assert that the counts of the next player's discard and deck counts
        -:  283:	are correct, such that their deckCount is 2 less than previously, and
        -:  284:	their discardCount is 2 greater than previously.*/
        3:  285:	if (before->deckCount[nextPlayer] - 2 != after->deckCount[nextPlayer])
branch  0 taken 0%
branch  1 taken 100%
        -:  286:	{
    #####:  287:		if (before->discardCount[nextPlayer] + 2 != after->discardCount[nextPlayer])
branch  0 never executed
branch  1 never executed
        -:  288:		{
    #####:  289:			printf("Tribute Error: next player's deckCount not -2 previous.\n");
    #####:  290:			printf("             : next player's discardCount not +2 previous.\n\n");
        -:  291:
    #####:  292:		}
    #####:  293:	}
        -:  294:
        -:  295:	/*Assert if one of the top 2 cards in the next player's discard
        -:  296:	are a coin, that the current player's coin is exactly 2 greater than previously.
        -:  297:	for each treasure in discard*/
        3:  298:	int totalCoin = 0;
        6:  299:	if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == copper ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        3:  300:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == silver ||
branch  0 taken 100%
branch  1 taken 0%
        3:  301:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == gold) {
        -:  302:
        -:  303:		// 1 treasure found
    #####:  304:		totalCoin += 2;
        -:  305:
    #####:  306:		if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == copper ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  307:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == silver ||
branch  0 never executed
branch  1 never executed
    #####:  308:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == gold) {
        -:  309:
        -:  310:			// 2nd treasure found
    #####:  311:			totalCoin += 2;
    #####:  312:		}
    #####:  313:	}
        -:  314:
        3:  315:	if (totalCoin == 2)
branch  0 taken 0%
branch  1 taken 100%
        -:  316:	{
    #####:  317:		if (before->coins + 2 != after->coins)
branch  0 never executed
branch  1 never executed
        -:  318:		{
    #####:  319:			printf("Tribute Error: You had 1 treasure in discard, but didn't gain 2 coin.\n\n");
    #####:  320:		}
    #####:  321:	}
        3:  322:	else if (totalCoin == 4)
branch  0 taken 0%
branch  1 taken 100%
        -:  323:	{
    #####:  324:		if (before->coins + 4 != after->coins)
branch  0 never executed
branch  1 never executed
        -:  325:		{
    #####:  326:			printf("Tribute Error: You had 2 treasures in discard, but didn't gain 4 coin.\n\n");
    #####:  327:		}
    #####:  328:	}
        -:  329:	/*Assert that if the current player's coin went up by 2 from previous, that
        -:  330:	the next player's top 2 discarded cards are a coin, otherwise print a message*/
        6:  331:	else if (totalCoin == 0 && (before->coins != after->coins))
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 33%
branch  3 taken 67%
        -:  332:	{
        1:  333:		printf("Tribute Error: You gained coin, but didn't find a treasure in discard.\n\n");
        1:  334:	}
        -:  335:
        -:  336:	/*Assert if one of the top 2 cards in the next player's discard
        -:  337:	are a victory card, that the current player's handCount is 2 greater than previously.*/
        3:  338:	int totalVictory = 0;
        6:  339:	if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == estate ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        3:  340:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == gardens) {
        -:  341:
        -:  342:		// 1 treasure found
    #####:  343:		totalVictory += 2;
        -:  344:
    #####:  345:		if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == estate ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  346:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == gardens) {
        -:  347:
        -:  348:			// 2nd treasure found
    #####:  349:			totalVictory += 2;
    #####:  350:		}
    #####:  351:	}
        -:  352:
        3:  353:	if (totalVictory == 2)
branch  0 taken 0%
branch  1 taken 100%
        -:  354:	{
    #####:  355:		if (before->handCount[nextPlayer] + 2 != after->handCount[nextPlayer])
branch  0 never executed
branch  1 never executed
        -:  356:		{
    #####:  357:			printf("Tribute Error: You had 1 Victory card in discard, but didn't gain 2 card.\n\n");
    #####:  358:		}
    #####:  359:	}
        3:  360:	else if (totalVictory == 4)
branch  0 taken 0%
branch  1 taken 100%
        -:  361:	{
    #####:  362:		if (before->handCount[nextPlayer] + 4 != after->handCount[nextPlayer])
branch  0 never executed
branch  1 never executed
        -:  363:		{
    #####:  364:			printf("Tribute Error: You had 2 Victory card in discard, but didn't gain 4 cards.\n\n");
    #####:  365:		}
    #####:  366:	}
        -:  367:	/*Assert that if the current player's hand count went up by 2 from previous, that
        -:  368:	the next player's top 2 discarded cards are a victory card.*/
        6:  369:	else if (totalVictory == 0 && (before->handCount[nextPlayer] != after->handCount[nextPlayer]))
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        -:  370:	{
    #####:  371:		printf("Tribute Error: You gained cards in hand, but didn't find a Victory card in discard.\n\n");
    #####:  372:	}
        -:  373:
        -:  374:	// This will catch the error.
        -:  375:	/*Assert that if the current player's numActions went up by 2 from previous, that
        -:  376:	the next player's top 2 discarded cards are an action card, otherwise print a message*/
        -:  377:
        3:  378:	int totalActions = 0;
        6:  379:	if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == adventurer ||
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100%
        3:  380:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == baron ||
branch  0 taken 100%
branch  1 taken 0%
        3:  381:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == tribute ||
branch  0 taken 100%
branch  1 taken 0%
        3:  382:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == minion ||
branch  0 taken 100%
branch  1 taken 0%
        3:  383:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == mine ||
branch  0 taken 100%
branch  1 taken 0%
        3:  384:		after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] == remodel) {
        -:  385:
        -:  386:		// 1 action found
    #####:  387:		totalActions += 2;
        -:  388:
    #####:  389:		if (after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == adventurer ||
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  390:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == baron ||
branch  0 never executed
branch  1 never executed
    #####:  391:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == tribute ||
branch  0 never executed
branch  1 never executed
    #####:  392:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == minion ||
branch  0 never executed
branch  1 never executed
    #####:  393:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == mine ||
branch  0 never executed
branch  1 never executed
    #####:  394:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] == remodel) {
        -:  395:
        -:  396:			// 2nd actions found
    #####:  397:			totalActions += 4;
    #####:  398:		}
    #####:  399:	}
        -:  400:
        3:  401:	if (totalActions == 2)
branch  0 taken 0%
branch  1 taken 100%
        -:  402:	{
    #####:  403:		if (before->numActions + 2 != after->numActions)
branch  0 never executed
branch  1 never executed
        -:  404:		{
    #####:  405:			printf("Tribute Error: You had 1 action card in discard, but didn't gain 2 actions.\n\n");
    #####:  406:		}
    #####:  407:	}
        3:  408:	else if (totalActions == 4)
branch  0 taken 0%
branch  1 taken 100%
        -:  409:	{
    #####:  410:		if (before->numActions + 4 != after->numActions)
branch  0 never executed
branch  1 never executed
        -:  411:		{
    #####:  412:			printf("Tribute Error: You had 2 action cards in discard, but didn't gain 4 actions.\n\n");
    #####:  413:		}
    #####:  414:	}
        6:  415:	else if (totalActions == 0 && (before->numActions != after->numActions))
branch  0 taken 100%
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  416:	{
        3:  417:		printf("Tribute Error: You gained actions, but didn't find any action cards in discard.\n\n");
        3:  418:	}
        -:  419:
        -:  420:	/*Assert that if the current player's hand count went up 2 from previous, that
        -:  421:	the next player's top 2 discarded cards are a victory card.
        -:  422:		If so compare the hands to see that the contents of the current player's hand
        -:  423:		is no the same as before.Use a for loop for i in G.handCount[currentPlayer],
        -:  424:		and compare contents.Any difference should break out of loop, set a print flag,
        -:  425:		and print the error.*/
        3:  426:	if (after->handCount[currentPlayer] > before->handCount[currentPlayer])
branch  0 taken 100%
branch  1 taken 0%
        -:  427:	{
        3:  428:		if ((after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] != estate ||
branch  0 taken 0%
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  429:		     after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] != estate) &&
branch  0 never executed
branch  1 never executed
        3:  430:		    (after->discard[nextPlayer][after->discardCount[nextPlayer] - 1] != gardens ||
branch  0 taken 0%
branch  1 taken 100%
    #####:  431:			after->discard[nextPlayer][after->discardCount[nextPlayer] - 2] != gardens) ){
        -:  432:
        -:  433:				// Then your handCount increased withou having a Victory card
        3:  434:				printf("Tribute Error: Your hand increased but..\n");
        3:  435:				printf("             : top 2 cards in next player's discard weren't Victory cards.\n\n");
        3:  436:			}
        3:  437:	}
        3:  438:}
