        -:    0:Source:bug1unittest.c
        -:    0:Graph:bug1unittest.gcno
        -:    0:Data:bug1unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*************************************************
        -:    2:* FileName: bug1unittest.c
        -:    3:* Author:	Glen Gougeon
        -:    4:* Class:	CS362 Software Engineering II
        -:    5:* Created:	11-29-2019
        -:    6:* Last Mod:	11-29-2019
        -:    7:* 
        -:    8:* Assignement: Final Project Part B/
        -:    9:*
        -:   10:* Description:	Unit Test for Bug 1: 
        -:   11:*				Mine Money to Trash only discards 
        -:   12:*
        -:   13:**************************************************/
        -:   14:#include <stdio.h>
        -:   15:#include <math.h>
        -:   16:#include <stdlib.h>
        -:   17:#include <string.h>
        -:   18:
        -:   19:#include "dominion.h"
        -:   20:#include "dominion_helpers.h"
        -:   21:#include "interface.h"
        -:   22:#include "rngs.h"
        -:   23:
        -:   24:// TEST PROTO-TYPES
        -:   25:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game);
        -:   26:
        -:   27:// HELPER PROTOS-TYPES
        -:   28:void emptyDeck(int player, struct gameState* state);
        -:   29:void emptyPlayedCards(struct gameState* state);
        -:   30:void emptyDiscard(int player, struct gameState* state);
        -:   31:
        -:   32:// HAND RELATED PROTO-TYPES
        -:   33:void emptyHand(int player, struct gameState* dState);
        -:   34:void setNewHandCount(int player, struct gameState* state, int newHandSize);
        -:   35:void setAtHandPos(int player, struct gameState* state, int card, int handPos);
        -:   36:
function main called 1 returned 100% blocks executed 68%
        -:   37:int main()
        -:   38:{
        1:   39:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        1:   40:	printf("*** START Bug1 Unit Test: Mine Money to Trash Only Discards ***\n");
        1:   41:	printf("MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n");
        1:   42:	printf("Note* discardCard() broken. Where would test contents of discard..\n");
        1:   43:	printf("      I am testing against contents of playedCards instead.\n\n");
        -:   44:
        -:   45:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   46:	/* ** SETUP TEST SECTION ** */
        -:   47:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   48:
        1:   49:	int kingdomCards[10] = { adventurer, ambassador, baron, estate, tribute, minion, mine,  gardens, remodel, smithy };
        -:   50:
        -:   51:	struct gameState G;
        -:   52:	struct gameState backup;
        -:   53:
        1:   54:	int seed = 1;
        1:   55:	int numPlayers = 2;
        1:   56:	int currentPlayer = 0;
        1:   57:	int newHandSize = 2;
        1:   58:	int mine_index = 0; // handPos remodel
        1:   59:	int idxOfChoice1 = 1; // choice1 mine
        1:   60:	int moneyToGet = silver; // choice2 mine
        1:   61:	int blank = -1;
        1:   62:	int coinBonus = 0;
        -:   63:
        -:   64:	// initialize and set currentPlayer
        1:   65:	initTestGame(numPlayers, kingdomCards, seed, &G);
        1:   66:	currentPlayer = G.whoseTurn;
        -:   67:
        -:   68:	// empty every deck currentPlayer has
        1:   69:	emptyDeck(currentPlayer, &G);
        1:   70:	emptyPlayedCards(&G); // req'd. b/c 'discardCard' is broken !!
        1:   71:	emptyDiscard(currentPlayer, &G);
        1:   72:	emptyHand(currentPlayer, &G);
        -:   73:
        -:   74:	// you will only have a copper in your hand
        1:   75:	setNewHandCount(currentPlayer, &G, newHandSize);
        -:   76:
        -:   77:	// place mine card in hand
        1:   78:	setAtHandPos(currentPlayer, &G, mine, mine_index);
        -:   79:
        -:   80:	// The only copper in the game is in currentPlayer's hand
        1:   81:	G.supplyCount[copper] = 0;
        -:   82:
        -:   83:	// The only silver in the game is THIS in supply
        1:   84:	G.supplyCount[silver] = 0;
        1:   85:	G.supplyCount[silver] = 1;
        -:   86:
        1:   87:	setAtHandPos(currentPlayer, &G, copper, idxOfChoice1);
        1:   88:	updateCoins(currentPlayer, &G, coinBonus);
        -:   89:
        -:   90:	/* BACK UP STATE BEFORE CALL */
        1:   91:	memset(&backup, '\0', sizeof(backup));
        1:   92:	backup = G;
        -:   93:	
        -:   94:	/* CALL TO MINE <-----------------------------------------------------*/
        1:   95:	cardEffect(mine, idxOfChoice1, moneyToGet, blank, &G, mine_index, &coinBonus);
        -:   96:
        -:   97:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:   98:	/* ** ASSERTS SECTION ** */
        -:   99:	/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  100:
        -:  101:	/*	Assert that choice1(an index) is a different card, otherwise print that it
        -:  102:		is the same. */
        1:  103:	if(backup.hand[currentPlayer][idxOfChoice1] == G.hand[currentPlayer][idxOfChoice1])
branch  0 taken 0%
branch  1 taken 100%
        -:  104:	{
    #####:  105:		printf("Error Mine: choice1 is still the same but shouldn't be.\n\n");
    #####:  106:	}
        -:  107:
        -:  108:	/*	Assert if top of previous discard was not the same as choice1, and
        -:  109:	choice1 is found at the top of discard, print 'choice1 discarded
        -:  110:	not trashed'. */
        -:  111:
        -:  112:	//if (backup.discard[currentPlayer][backup.discardCount[currentPlayer] - 1] != copper)
        1:  113:	if (backup.playedCards[backup.playedCardCount - 1] != copper)
branch  0 taken 100%
branch  1 taken 0%
        -:  114:	{
        1:  115:		if (G.playedCards[G.playedCardCount - 1] == copper)
branch  0 taken 100%
branch  1 taken 0%
        -:  116:		{
        -:  117:			//printf("Error 'discardCard': should be discard .. but is playedCards array\n");
        1:  118:			printf("Error Mine: choice1 found in playedCards, but should be at top of trashPile.\n\n");
        1:  119:		}
        1:  120:	}
        -:  121:
        -:  122:	/*	Assert if top of previous discard was the same as choice1, and the
        -:  123:	top 2 cards in discard are both choice1, print 'choice1 discarded
        -:  124:	not trashed'. */
        -:  125:	//if (backup.discard[currentPlayer][backup.discardCount[currentPlayer] -1] == copper)
        -:  126:	//{
        -:  127:	//	if ((G.discard[currentPlayer][G.discardCount[currentPlayer] - 1] == copper) &&
        -:  128:	//	    (G.discard[currentPlayer][G.discardCount[currentPlayer] - 2] == copper))
        -:  129:	//	{
        -:  130:	//		printf("Error Mine: choice1 discarded not trashed.\n\n");
        -:  131:	//	}
        -:  132:	//}
        -:  133:
        1:  134:	if (backup.playedCards[backup.playedCardCount - 1] == copper)
branch  0 taken 0%
branch  1 taken 100%
        -:  135:	{
    #####:  136:		if ((G.playedCards[G.playedCardCount - 1] == copper) &&
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  137:			(G.playedCards[G.playedCardCount - 2] == copper))
        -:  138:		{
        -:  139:			//printf("Error 'discardCard': should be discard .. but is playedCards array\n");
    #####:  140:			printf("Error Mine: choice1 found in playedCards NOT in trash.\n\n");
    #####:  141:		}
    #####:  142:	}
        -:  143:
        -:  144:	/*	Assert that the discardCount has not changed, otherwise print
        -:  145:		'discardCount changed but shouldn't have'. */
        -:  146:
        -:  147:	//if (backup.discardCount[currentPlayer] != G.discardCount[currentPlayer])
        1:  148:	if (backup.playedCardCount -1 != G.playedCardCount -1)
branch  0 taken 100%
branch  1 taken 0%
        -:  149:	{
        -:  150:		//printf("Error 'discardCard': should be discardCount .. but is playedCardCount array\n");
        1:  151:		printf("Error Mine: playedCardCount changed.\n\n");
        1:  152:	}
        -:  153:
        -:  154:	/* The handCount should change.
        -:  155:	   Assert if backup.handCount[currentPlayer] == G.handCount[currentPlayer]
        -:  156:	   print 'Error Mine: handCount didn't change.\n'	*/
        1:  157:	if (backup.handCount[currentPlayer] == G.handCount[currentPlayer])
branch  0 taken 0%
branch  1 taken 100%
        -:  158:	{
    #####:  159:		printf("Error Mine: handCount didn't change.\n");
    #####:  160:	}
        -:  161:
        -:  162:	/*	Assert if backup.supplyCount[choice2] > 0 and choice2 was not in
        -:  163:		previous hand, and is not in current hand, print
        -:  164:		'choice2 not found in hand after mine'. */
        1:  165:	if (backup.supplyCount[moneyToGet] > 0)
branch  0 taken 100%
branch  1 taken 0%
        -:  166:	{
        1:  167:		int found = 0;
        -:  168:		int iter;
        2:  169:		for (iter = 0; iter < G.handCount[currentPlayer]; iter++)
branch  0 taken 100%
branch  1 taken 0%
        -:  170:		{
        -:  171:			// is it in hand now ??
        1:  172:			if (G.hand[currentPlayer][iter] == moneyToGet)
branch  0 taken 100%
branch  1 taken 0%
        -:  173:			{
        1:  174:				found = 1;
        1:  175:				break;
        -:  176:			}
        -:  177:
    #####:  178:		}
        -:  179:
        1:  180:		if (found)
branch  0 taken 100%
branch  1 taken 0%
        -:  181:		{
        1:  182:			printf("Error Mine: choice2 not found in hand after the call.\n\n");
        1:  183:		}
        -:  184:
        1:  185:	}
        -:  186:
        -:  187:	/*	Compare the supplyCount[silver] before and after the call.If the
        -:  188:		current count is not 1 less than previous, then print
        -:  189:		'choice2 silver not 1 less than previous' */
        1:  190:	if (backup.supplyCount[silver] - 1 != G.supplyCount[silver])
branch  0 taken 0%
branch  1 taken 100%
        -:  191:	{
    #####:  192:		printf("Error Mine: choice2 silver is not -1 previous supplyCount.\n\n");
    #####:  193:	}
        -:  194:
        1:  195:	printf("*** END Bug1 Unit Test ***\n\n");
        1:  196:	return 0;
        -:  197:}
        -:  198:
        -:  199:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  200:/* *** FUNCTION SPECIFICATIONS ***																	*/
        -:  201:/* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */
        -:  202:
        -:  203:/* This function adds memset initialization, and prints error if fail  */
function initTestGame called 1 returned 100% blocks executed 75%
        -:  204:void initTestGame(int numPlayers, int* kDeck, int mySeed, struct gameState* game)
        -:  205:{
        1:  206:	memset(game, '\0', sizeof(struct gameState));   // clear mem of 
        -:  207:
        1:  208:	int checkInit = initializeGame(numPlayers, kDeck, mySeed, game); // initialize 2 player game 
        -:  209:
        1:  210:	if (checkInit == -1)
branch  0 taken 0%
branch  1 taken 100%
        -:  211:	{
    #####:  212:		printf("Bad game initialization.\n");
    #####:  213:	}
        -:  214:
        1:  215:}
        -:  216:
        -:  217:// set player to remove all cards from current player's deck  
function emptyDeck called 1 returned 100% blocks executed 100%
        -:  218:void emptyDeck(int player, struct gameState* state)
        -:  219:{
        1:  220:	int i = 0;
       12:  221:	while (i < state->deckCount[player])
branch  0 taken 83%
branch  1 taken 17%
        -:  222:	{
        5:  223:		state->deck[player][i] = -1;
        5:  224:		i++;
        -:  225:	}
        1:  226:	state->deckCount[player] = 0;
        1:  227:}
        -:  228:
        -:  229:// set player to remove all cards from current player's deck   
function emptyPlayedCards called 1 returned 100% blocks executed 80%
        -:  230:void emptyPlayedCards(struct gameState* state)
        -:  231:{
        1:  232:	int i = 0;
        2:  233:	while (i < state->playedCardCount)
branch  0 taken 0%
branch  1 taken 100%
        -:  234:	{
    #####:  235:		state->playedCards[i] = -1;
    #####:  236:		i++;
        -:  237:	}
        1:  238:	state->playedCardCount = 0;
        1:  239:}
        -:  240:
        -:  241:// eliminate all cards from discard.   
function emptyDiscard called 1 returned 100% blocks executed 80%
        -:  242:void emptyDiscard(int player, struct gameState* state)
        -:  243:{
        1:  244:	int i = 0;
        2:  245:	while (i < state->discardCount[player])
branch  0 taken 0%
branch  1 taken 100%
        -:  246:	{
    #####:  247:		state->discard[player][i] = -1;
    #####:  248:		i++;
        -:  249:	}
        1:  250:	state->discardCount[player] = 0;
        1:  251:}
        -:  252:
        -:  253:/* Sets current player's handCount to newHandSize, then
        -:  254:	overwrites everything in hand with -1 */
function emptyHand called 1 returned 100% blocks executed 100%
        -:  255:void emptyHand(int player, struct gameState* state)
        -:  256:{
        -:  257:	int i;
       12:  258:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17%
        -:  259:	{
        5:  260:		state->hand[player][i] = -1;
        5:  261:	}
        1:  262:	state->handCount[player] = 0;
        1:  263:}
        -:  264:
        -:  265:// sets handCount of player to newHandSize
function setNewHandCount called 1 returned 100% blocks executed 100%
        -:  266:void setNewHandCount(int player, struct gameState* state, int newHandSize)
        -:  267:{
        1:  268:	state->handCount[player] = newHandSize;
        1:  269:}
        -:  270:
        -:  271:// adds indicated card in current player's hand at handPos 
function setAtHandPos called 2 returned 100% blocks executed 100%
        -:  272:void setAtHandPos(int player, struct gameState* state, int card, int handPos)
        -:  273:{
        2:  274:	state->hand[player][handPos] = card;
        2:  275:}
