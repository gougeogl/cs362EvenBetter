        -:    0:Source:bug5unittest.c
        -:    0:Graph:bug5unittest.gcno
        -:    0:Data:bug5unittest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:#include "dominion.h"
        -:    3:#include "dominion_helpers.h"
        -:    4:#include "rngs.h"
        -:    5:#include <stdio.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:
        -:    9:
        -:   10:
function assertScoreFor called 1 returned 100% blocks executed 80%
        -:   11:void assertScoreFor (int testScore, int calcScore) {
        -:   12:
        -:   13:    // Assertion
        1:   14:    if (testScore == calcScore) {
branch  0 taken 100%
branch  1 taken 0%
        1:   15:        printf("Score is correctly calculated for current player. No errors.\n\n");
        1:   16:    }
        -:   17:    else {
    #####:   18:        printf("Score is incorrectly calculated for current player. Error detected.\n\n");
        -:   19:    }
        1:   20:}
        -:   21:
        -:   22:
        -:   23:
function calculateScore called 1 returned 100% blocks executed 52%
        -:   24:int calculateScore (int player, struct gameState *state) {
        -:   25:
        -:   26:    int i;
        1:   27:    int score = 0;
        -:   28:    //score from hand
       12:   29:    for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17%
        -:   30:    {
        5:   31:        if (state->hand[player][i] == curse) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   32:            score = score - 1;
    #####:   33:        };
        5:   34:        if (state->hand[player][i] == estate) {
branch  0 taken 20%
branch  1 taken 80%
        1:   35:            score = score + 1;
        1:   36:        };
        5:   37:        if (state->hand[player][i] == duchy) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   38:            score = score + 3;
    #####:   39:        };
        5:   40:        if (state->hand[player][i] == province) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   41:            score = score + 6;
    #####:   42:        };
        5:   43:        if (state->hand[player][i] == great_hall) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   44:            score = score + 1;
    #####:   45:        };
        5:   46:        if (state->hand[player][i] == gardens) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   47:            score = score + ( fullDeckCount(player, 0, state) / 10 );
    #####:   48:        };
        5:   49:    }
        -:   50:
        -:   51:    //score from discard
        2:   52:    for (i = 0; i < state->discardCount[player]; i++)
branch  0 taken 0%
branch  1 taken 100%
        -:   53:    {
    #####:   54:        if (state->discard[player][i] == curse) {
branch  0 never executed
branch  1 never executed
    #####:   55:            score = score - 1;
    #####:   56:        };
    #####:   57:        if (state->discard[player][i] == estate) {
branch  0 never executed
branch  1 never executed
    #####:   58:            score = score + 1;
    #####:   59:        };
    #####:   60:        if (state->discard[player][i] == duchy) {
branch  0 never executed
branch  1 never executed
    #####:   61:            score = score + 3;
    #####:   62:        };
    #####:   63:        if (state->discard[player][i] == province) {
branch  0 never executed
branch  1 never executed
    #####:   64:            score = score + 6;
    #####:   65:        };
    #####:   66:        if (state->discard[player][i] == great_hall) {
branch  0 never executed
branch  1 never executed
    #####:   67:            score = score + 1;
    #####:   68:        };
    #####:   69:        if (state->discard[player][i] == gardens) {
branch  0 never executed
branch  1 never executed
    #####:   70:            score = score + ( fullDeckCount(player, 0, state) / 10 );
    #####:   71:        };
    #####:   72:    }
        -:   73:
        -:   74:    //score from deck
       12:   75:    for (i = 0; i < state->deckCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17%
        -:   76:    {
        5:   77:        if (state->deck[player][i] == curse) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   78:            score = score - 1;
    #####:   79:        };
        5:   80:        if (state->deck[player][i] == estate) {
branch  0 taken 40%
branch  1 taken 60%
        2:   81:            score = score + 1;
        2:   82:        };
        5:   83:        if (state->deck[player][i] == duchy) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   84:            score = score + 3;
    #####:   85:        };
        5:   86:        if (state->deck[player][i] == province) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   87:            score = score + 6;
    #####:   88:        };
        5:   89:        if (state->deck[player][i] == great_hall) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   90:            score = score + 1;
    #####:   91:        };
        5:   92:        if (state->deck[player][i] == gardens) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   93:            score = score + ( fullDeckCount(player, 0, state) / 10 );
    #####:   94:        };
        5:   95:    }
        -:   96:
        1:   97:    return score;
        -:   98:}
        -:   99:
        -:  100:
        -:  101:
function main called 1 returned 100% blocks executed 100%
        -:  102:int main () {
        -:  103:
        1:  104:printf("/****************************************\n");
        1:  105:printf("/***********   BUG 5 TEST   *************\n");
        1:  106:printf("/****************************************\n");
        -:  107:
        1:  108:int currentPlayer = 0;
        -:  109:
        -:  110:struct gameState G;
        -:  111:
        1:  112:int * k = kingdomCards(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        -:  113:
        1:  114:initializeGame (2, k, 8, &G);
        -:  115:
        1:  116:int testScore = calculateScore(currentPlayer, &G);
        -:  117:
        1:  118:int calcScore = scoreFor (currentPlayer, &G);
        -:  119:
        1:  120:assertScoreFor(testScore, calcScore);
        -:  121:
        1:  122:printf("\n");
        1:  123:printf("\n");
        1:  124:printf("\n");
        -:  125:
        1:  126:return 0;
        -:  127:};
